---
title: "yes_data_cleaning"
author: "Mallory Dobias"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    toc: yes
    toc_depth: 5
    toc_float:
      collapsed: no
      smooth_scroll: no
  pdf_document:
    toc: yes
    toc_depth: '5'
  word_document:
    toc: yes
    toc_depth: '5'
geometry: margin=0.50in
---

```{r setup, include=FALSE}

## Setting up R

knitr::opts_chunk$set(echo = TRUE)

if(!require(pointblank)){install.packages('pointblank')}
library(pointblank) # installing and calling pointblank package early in Markdown

validate_rmd(summary = TRUE, log_to_file = FALSE) # allowing validation from pointblank package within Markdown

```

```{r, include=FALSE}

if(!require(here)){install.packages('here')}
library(here)

if(!require(janitor)){install.packages('janitor')}
library(janitor)

if(!require(dplyr)){install.packages('dplyr')}
library(dplyr)

if(!require(stringr)){install.packages('stringr')}
library(stringr)

if(!require(pointblank)){install.packages('pointblank')}
library(pointblank)

if(!require(tidyr)){install.packages('tidyr')}
library(tidyr)

```

# Data Reading

```{r reading in data}

## Reading in NU English survey data

library(here) # places working directory at root of project folder

raw_data <- read.csv(here("data", "raw", "NU - YES - English - Questionnaires Optional_October 31, 2024_14.42.csv")) # directing to data from project folder root

# head(raw_data)

```

# Data Cleaning

## Cleaning Var Names

Removing Qualtrics metadata rows

```{r removing first two Qualtrics metadata rows}

## Removing first two rows with Qualtrics metadata

data_sliced <- raw_data %>%
  dplyr::slice(-1,-2)

# head(data_sliced) # looks good

```

```{r checking metadata removal setup, include = FALSE}

## checking Qualtrics metadata rows are removed

# pulling row 3 of raw data to compare to row 1 of sliced data

test_sliced_pre <- raw_data %>%
  dplyr::slice(3) # pulling pre-removal row 3 for comparison

test_sliced_post <- data_sliced %>%
  dplyr::slice(1) # pulling post-removal row 1 for comparison

# combining into one dataframe

test_sliced <- rbind(test_sliced_pre, test_sliced_post)

```

Checking metadata rows removed correctly

```{r checking metadata removal, validate = TRUE}

test_sliced %>%
  pointblank::col_vals_equal(vars(ResponseId), 
                             vars(ResponseId)) # passes if third row response is now first row

```

Converting to tidy var names

```{r creating tidy names}

## Cleaning var names

data_named <- data_sliced %>%
  janitor::clean_names()

# head(data_named)

```

Checking var names are tidy

```{r checking tidy names setup}

## checking var names are now tidy

test_var_names <- tibble(col_names = names(data_named)) # creates data frame of names

test_var_names %>%
  filter(stringr::str_detect(col_names, "[A-Z]")) %>%
  nrow() == 0 # true if zero col names contain capital letters

```

Renaming unlabeled project rise vars

```{r naming rise vars}

## Naming RISE vars

# first insert an underscore, then replace q vars with rise var name labels

data_rise_named <- data_named %>%
  rename_with(~str_replace(., "^q([0-9]+)", "q_\\1"), starts_with("q")) %>%
  rename_with(~ str_replace(., "^q_", "proj_rise_q_"), starts_with("q_"))

```

```{r checking rise var naming setup, include = FALSE}

## checking rise vars are named correctly

test_rise_pre <- data_named %>%
  select(starts_with("q"), -questionnaires, -contains("text")) %>%
  rename_with(~ str_extract(., "\\d+")) %>% # extract digits from rise var names pre cleaning
  colnames() # create df of pre-named var names for comparison

test_rise_post <- data_rise_named %>%
  select(starts_with("proj_rise_"), -contains("commit"), -contains("text")) %>%
  rename_with(~ str_extract(., "\\d+")) %>% # extract digits from rise var names post cleaning
  colnames() # create df of post-named var names for comparison

test_rise_naming_df <- tibble(test_rise_pre, test_rise_post) # creating df for validation

```

Checking columns renamed correctly

```{r checking var naming, validate = TRUE}

test_rise_naming_df %>%
  pointblank::col_vals_equal(vars(test_rise_pre), 
                             vars(test_rise_post)) # passes if renamed columns are identical to original cols

```

Renaming "pi_" (post-intervention) variable prefixes to "post_" prefixes, for clarity

```{r renaming pi vars with post label}

## Renaming "pi_" (post-intervention) vars with "post_" prefix for clarity

data_post_named <- data_rise_named %>%
  rename_with(~ str_replace(., "^pi_", "post_"))

```

```{r checking post var naming setup, include = FALSE}

## checking vars are renamed correctly

# extracting characters following "pre_" in column names before renaming

test_pre_rename <- tibble(var_names = names(data_rise_named)) %>%
  filter(str_detect(var_names, "^pre_") & !str_detect(var_names, "tim")) %>% # keep non-time rows with "pre_" prefix
  mutate(pre_renamed = str_extract(var_names, "(?<=pre_).*")) %>% # extract characters following "pre_"
  select(-var_names)

# extracting characters following "post_" in column names after renaming

test_post_rename <- tibble(var_names = names(data_post_named)) %>%
  filter(str_detect(var_names, "^post_") & !str_detect(var_names, "tim")) %>% # keep non-time rows with "post_" prefix
  mutate(post_renamed = str_extract(var_names, "(?<=post_).*")) %>% # extract characters following "post_"
  select(-var_names)

# combining to one data frame for comparison

test_rename <- cbind(test_pre_rename, test_post_rename)

```

Checking columns renamed correctly

```{r checking post var renaming, validate = TRUE}

test_rename %>%
  pointblank::col_vals_equal(vars(pre_renamed), 
                             vars(post_renamed)) # passes if renamed columns are identical to original cols

```

## Calculating Composites

### Depression

Calculating depressive symptoms using the Short Form Mood and Feelings Questionnaire (only measured pre-SSI). Scores range from 0 to 26, where 0 = not true, 1 = sometimes, 2 = true. Scores of 12 or higher suggest depression. Source: https://doi.org/10.1002/mpr.1610

```{r pulling mfq values, include=FALSE}

## Pulling mfq variables

# vars_mfq <- data_post_named %>%
#   select(contains("mfq")) %>%
#   head() %>%
#   print()

```

Mutating mfq character values to numeric values

```{r mutating mfq values}

## Mutating character values to numeric across multiple mfq columns 

data_mfq_mutated <- data_post_named %>%
  mutate(across(starts_with("mfq_") & -contains("tim"), 
                ~ case_when(
                    . == "Not True" ~ 0,
                    . == "Sometimes" ~ 1,
                    . == "True" ~ 2,
                    TRUE ~ NA_real_ # Handle other cases with NA
                )))

```

Checking mfq variables are now numeric class

```{r mfq numeric class check}

## Checking that all mfq vars are numeric class

data_mfq_mutated %>%
  select(contains("mfq") & -contains("tim")) %>%
  summarise(across(everything(), ~ class(.x)[1])) %>%
  tidyr::pivot_longer(cols = everything(), names_to = "variable", values_to = "class")


```

```{r checking mfq mutation setup, include=FALSE}

## checking mutation happened correctly - setting up for pointblank tests

# creating df of count for each response, pre mutation

test_mfq_pre <- data_post_named %>%
  group_by(mfq_1) %>% # grouping by response
  summarize(count = n()) %>% # counting responses pre-mutation
  arrange(desc(count)) %>% # arranged in descending count order
  rename(mfq_1_pre = mfq_1, count_pre = count) # renaming before combining to one df

# creating df of count for each response, post mutation

test_mfq_post <- data_mfq_mutated %>%
  mutate(across(starts_with("mfq_"), 
                ~ factor(., levels = unique(.)))) %>% # converting to factor class so we can count
  group_by(mfq_1) %>% # grouping by response
  summarize(count = n()) %>% # counting responses post-mutation
  arrange(desc(count)) %>% # arranged in descending count order
  rename(mfq_1_post = mfq_1, count_post = count) # renaming before combining to one df

# creating overall df for comparison

test_mfq_mutate <- cbind(test_mfq_pre, test_mfq_post)

```

```{r writing a function to setup future mutation checks, include=FALSE}

# Custom function to compare value counts before and after mutation
prep_mutation_check <- function(data_pre, data_post, var) {
  
  # Step 1: Create pre-mutation counts
  test_pre <- data_pre %>%
    select(var) %>%
    group_by(across(all_of(var))) %>%  # Group by the specified variable
    summarize(count = n(), .groups = "drop") %>%  # Count occurrences
    arrange(desc(count)) %>%  # Arrange in descending order
    rename_with(~ paste0(., "_pre"), everything())  # Rename columns for pre-mutation
  
  # Step 2: Create post-mutation counts
  test_post <- data_post %>%
    select(var) %>%
    mutate(across(all_of(var), ~ factor(., levels = unique(.)))) %>%  # Convert to factor
    group_by(across(all_of(var))) %>%  # Group by the specified variable
    summarize(count = n(), .groups = "drop") %>%  # Count occurrences
    arrange(desc(count)) %>%  # Arrange in descending order
    rename_with(~ paste0(., "_post"), everything())  # Rename columns for post-mutation
  
  # Step 3: Combine pre and post counts into one dataframe for comparison
  test_comparison <- bind_cols(test_pre, test_post)
  
  return(test_comparison)
}

```

```{r testing function to setup future mutation checks, include=FALSE}

# Example usage:
# Assuming `data_post_named` is the pre-mutation dataframe
# and `data_mfq_mutated` is the post-mutation dataframe,
# and you want to compare the value counts of "mfq_1":

test_mutate <- prep_mutation_check(data_post_named, data_mfq_mutated, "mfq_1") # same output as test_mfq_mutate above

## will use the prep_mutation_check() function to set up mutation checks moving forward

```

Checking mfq response counts are identical from pre to post mutation

```{r mfq response counts validation, validate = TRUE}

test_mutate %>%
  pointblank::col_vals_equal(vars(count_pre), 
                             vars(count_post)) # passes if response counts are identical pre to post mutation

```

Calculating mfq composite scores

```{r calculating mfq scores}

## Calculating composite mfq scores

data_mfq_scored <- data_mfq_mutated %>%
  mutate(mfq_total = rowSums(across(starts_with("mfq_") & -contains("tim"))))

```

```{r checking mfq score setup, include = FALSE}

## checking composite calculation was correct

# manually calculating mfq totals to compare sum methods

test_mfq_calc <- data_mfq_scored %>%
  select(response_id, starts_with("mfq_") & -contains("tim")) %>%
  mutate(manual_mfq_total = mfq_1 + mfq_2 + mfq_3 + mfq_4 + mfq_5 +
                            mfq_6 + mfq_7 + mfq_8 + mfq_9 + mfq_10 +
                            mfq_11 + mfq_12 + mfq_13) %>%
  select(mfq_total, manual_mfq_total)

```

Checking mfq totals are identical across sum methods

```{r mfq scoring validation, validate = TRUE}

test_mfq_calc %>%
  pointblank::col_vals_equal(vars(mfq_total), 
                             vars(manual_mfq_total), 
                             na_pass = TRUE) # passes if mfq totals are identical across sum methods

```

### Hopelessness

Calculating hopelessness using the 4-item Beck's Hopelessness Scale (measured pre and post SSI). Row mean scores range from 0 to 3, where 0 = absolutely disagree, 1 = somewhat disagree, 2 = somewhat agree, 3 = absolutely agree on each item. Source: https://doi.org/10.1007/s10597-013-9619-1

```{r pulling bhs values, include=FALSE}

## Pulling mfq variables

# vars_bhs <- data_mfq_scored %>%
#   select(contains("bhs")) %>%
#   head() %>%
#   print()

```

Mutating bhs character values to numeric values

```{r mutating bhs values}

## Mutating character values to numeric across multiple bhs columns 

data_bhs_mutated <- data_mfq_scored %>%
  mutate(across(contains("bhs_") & -contains("tim"), 
                ~ case_when(
                    . == "Absolutely disagree" ~ 0,
                    . == "Somewhat disagree" ~ 1,
                    . == "Somewhat agree" ~ 2,
                    . == "Absolutely agree" ~ 3,
                    TRUE ~ NA_real_ # Handle other cases with NA
                )))

```

Checking bhs variables are now numeric class

```{r bhs numeric class check}

## Checking that all bhs vars are numeric class

data_bhs_mutated %>%
  select(contains("bhs")) %>%
  summarise(across(everything(), ~ class(.x)[1])) %>%
  tidyr::pivot_longer(cols = everything(), names_to = "variable", values_to = "class")


```

```{r using function to setup bhs mutation check, include=FALSE}

# `data_mfq_scored` is the pre-mutation dataframe
# and `data_bhs_mutated` is the post-mutation dataframe,
# and we want to compare the value counts of "pre_bhs_1":

test_mutate <- prep_mutation_check(data_mfq_scored, data_bhs_mutated, "pre_bhs_1")

```

Checking bhs response counts are identical from pre to post mutation

```{r bhs response counts validation, validate = TRUE}

test_mutate %>%
  pointblank::col_vals_equal(vars(count_pre), 
                             vars(count_post)) # passes if response counts are identical pre to post mutation

```

Calculating bhs row means

```{r calculating bhs scores}

## Calculating composite scores

data_bhs_scored <- data_bhs_mutated %>%
  mutate(pre_bhs_mean = rowMeans(across(starts_with("pre_bhs_") & -contains("tim")), na.rm = TRUE),
         post_bhs_mean = rowMeans(across(starts_with("post_bhs_") & -contains("tim")), na.rm = TRUE)) %>%
  mutate(across(contains("bhs_"), ~ case_when(
                                  is.nan(.) ~ NA_real_, # Replace NaN with NA
                                  TRUE ~ .))) # Keep other values unchanged

```

```{r checking bhs score setup, include = FALSE}

## checking composite calculation was correct

# manually calculating pre totals to compare sum methods

test_pre_bhs_calc <- data_bhs_scored %>%
  select(response_id, starts_with("pre_bhs_") & -contains("tim")) %>%
  mutate(pre_manual_mean = rowMeans(select(., pre_bhs_1, pre_bhs_2, pre_bhs_3, pre_bhs_4), na.rm = TRUE)) %>%
  mutate(across(contains("manual"), ~ case_when(is.nan(.) ~ NA_real_, # Replace NaN with NA
                                        TRUE ~ .))) %>% # Keep other values unchanged
  select(pre_bhs_mean, pre_manual_mean)

# manually calculating post totals to compare sum methods

test_post_bhs_calc <- data_bhs_scored %>%
  select(response_id, starts_with("post_bhs_") & -contains("tim")) %>%
  mutate(post_manual_mean = rowMeans(select(., post_bhs_1, post_bhs_2, post_bhs_3, post_bhs_4), na.rm = TRUE)) %>%
  mutate(across(contains("manual"), ~ case_when(is.nan(.) ~ NA_real_, # Replace NaN with NA
                                        TRUE ~ .))) %>% # Keep other values unchanged
  select(post_bhs_mean, post_manual_mean)

```

Checking pre and post bhs means are identical across averaging methods

```{r pre bhs scoring validation, validate = TRUE}

test_pre_bhs_calc %>%
  pointblank::col_vals_equal(vars(pre_bhs_mean), 
                             vars(pre_manual_mean), 
                             na_pass = TRUE) # passes if means are identical across methods

```

```{r post bhs scoring validation, validate = TRUE}

test_post_bhs_calc %>%
  pointblank::col_vals_equal(vars(post_bhs_mean), 
                             vars(post_manual_mean), 
                             na_pass = TRUE) # passes if means are identical across methods

```

### Hope (Pathways)

Calculating hope using the 3-item pathways subscale from the State Hope Scale (measured pre and post SSI). Row mean scores range from 0 to 8, where 1 = definitely false, and 8 = definitely true. Source: https://doi.org/10.1037/0022-3514.70.2.321

```{r pulling shs values, include=FALSE}

## Pulling shs variables

# vars_shs <- data_bhs_scored %>%
#   select(contains("shs")) %>%
#   head() %>%
#   print()

```

Mutating shs character values to numeric values

```{r mutating shs values}

## Mutating character values to numeric across multiple shs columns 

data_shs_mutated <- data_bhs_scored %>%
  mutate(across(contains("shs_") & -contains("tim"), 
                ~ case_when(
                    . == "Definitely False" ~ 1,
                    . == "Mostly False" ~ 2,
                    . == "Somewhat False" ~ 3,
                    . == "Slightly False" ~ 4,
                    . == "Slightly True" ~ 5,
                    . == "Somewhat True" ~ 6,
                    . == "Mostly True" ~ 7,
                    . == "Definitely True" ~ 8,
                    TRUE ~ NA_real_ # Handle other cases with NA
                )))
 
```

Checking shs variables are now numeric class

```{r shs numeric class check}

## Checking that all shs vars are numeric class

data_shs_mutated %>%
  select(contains("shs")) %>%
  summarise(across(everything(), ~ class(.x)[1])) %>%
  tidyr::pivot_longer(cols = everything(), names_to = "variable", values_to = "class")


```

```{r using function to setup shs mutation check, include=FALSE}

# `data_bhs_scored` is the pre-mutation dataframe
# and `data_shs_mutated` is the post-mutation dataframe,
# and we want to compare the value counts of "pre_shs_1":

test_mutate <- prep_mutation_check(data_bhs_scored, data_shs_mutated, "pre_shs_1")

```

Checking shs response counts are identical from pre to post mutation

```{r shs response counts validation, validate = TRUE}

test_mutate %>%
  pointblank::col_vals_equal(vars(count_pre), 
                             vars(count_post)) # passes if response counts are identical pre to post mutation

```
Calculating shs row means

```{r calculating shs scores}

## Calculating composite scores

data_shs_scored <- data_shs_mutated %>%
  mutate(pre_shs_mean = rowMeans(across(starts_with("pre_shs_") & -contains("tim")), na.rm = TRUE),
         post_shs_mean = rowMeans(across(starts_with("post_shs_") & -contains("tim")), na.rm = TRUE)) %>%
  mutate(across(contains("shs_"), ~ case_when(
                                  is.nan(.) ~ NA_real_, # Replace NaN with NA
                                  TRUE ~ .))) # Keep other values unchanged

```

```{r checking shs score setup, include = FALSE}

## checking composite calculation was correct

# manually calculating pre totals to compare sum methods

test_pre_shs_calc <- data_shs_scored %>%
  select(response_id, starts_with("pre_shs_") & -contains("tim")) %>%
  mutate(pre_manual_mean = rowMeans(select(., pre_shs_1, pre_shs_2, pre_shs_3), na.rm = TRUE)) %>%
  mutate(across(contains("manual"), ~ case_when(is.nan(.) ~ NA_real_, # Replace NaN with NA
                                        TRUE ~ .))) %>% # Keep other values unchanged
  select(pre_shs_mean, pre_manual_mean)

# manually calculating post totals to compare sum methods

test_post_shs_calc <- data_shs_scored %>%
  select(response_id, starts_with("post_shs_") & -contains("tim")) %>%
  mutate(post_manual_mean = rowMeans(select(., post_shs_1, post_shs_2, post_shs_3), na.rm = TRUE)) %>%
  mutate(across(contains("manual"), ~ case_when(is.nan(.) ~ NA_real_, # Replace NaN with NA
                                        TRUE ~ .))) %>% # Keep other values unchanged
  select(post_shs_mean, post_manual_mean)

```

Checking pre and post shs means are identical across averaging methods

```{r pre shs scoring validation, validate = TRUE}

test_pre_shs_calc %>%
  pointblank::col_vals_equal(vars(pre_shs_mean), 
                             vars(pre_manual_mean), 
                             na_pass = TRUE) # passes if means are identical across methods

```

```{r post shs scoring validation, validate = TRUE}

test_post_shs_calc %>%
  pointblank::col_vals_equal(vars(post_shs_mean), 
                             vars(post_manual_mean), 
                             na_pass = TRUE) # passes if means are identical across methods

```

### Self-Hate

Calculating self-hate using a 3-item version of the Self-Hate Scale (measured pre and post SSI). Row mean scores range from 1 to 6, where 1 = not at all true for me, and 6 = very true for me. Source (abbreviated scale): https://mental.jmir.org/2020/6/e20513. Source (full scale): https://doi.org/10.1016/j.jad.2018.11.047 

NOTE: The original scale is a 7-point Likert scale, we've used 6-point Likert scales for items in this data and in the original YES data. 

```{r pulling selfhate values, include=FALSE}

## Pulling selfhate variables

# vars_hate <- data_shs_scored %>%
#   select(contains("self_hate")) %>%
#   head() %>%
#   print()

```

Mutating hate character values to numeric values

```{r mutating hate values}

## Converting number character values from sliding scale to numeric values

data_hate_mutated <- data_shs_scored %>%
  mutate(across(contains("self_hate") & where(is.character), as.numeric))

```

Checking hate variables are now numeric class

```{r hate numeric class check}

## Checking that all self-hate vars are numeric class

data_hate_mutated %>%
  select(contains("self_hate")) %>%
  summarise(across(everything(), ~ class(.x)[1])) %>%
  tidyr::pivot_longer(cols = everything(), names_to = "variable", values_to = "class")


```

Calculating hate row means

```{r calculating hate scores}

## Calculating composite scores

data_hate_scored <- data_hate_mutated %>%
  mutate(pre_self_hate_mean = rowMeans(across(starts_with("pre_self_hate_") & -contains("tim")), na.rm = TRUE),
         post_self_hate_mean = rowMeans(across(starts_with("post_self_hate_") & -contains("tim")), na.rm = TRUE)) %>%
  mutate(across(contains("self_hate_"), ~ case_when(
                                  is.nan(.) ~ NA_real_, # Replace NaN with NA
                                  TRUE ~ .))) # Keep other values unchanged

```

```{r checking hate score setup, include = FALSE}

## checking composite calculation was correct

# manually calculating pre totals to compare sum methods

test_pre_hate_calc <- data_hate_scored %>%
  select(response_id, starts_with("pre_self_hate_") & -contains("tim")) %>%
  mutate(pre_manual_mean = rowMeans(select(., pre_self_hate_1, pre_self_hate_2, pre_self_hate_3), na.rm = TRUE)) %>%
  mutate(across(contains("manual"), ~ case_when(is.nan(.) ~ NA_real_, # Replace NaN with NA
                                        TRUE ~ .))) %>% # Keep other values unchanged
  select(pre_self_hate_mean, pre_manual_mean)

# manually calculating post totals to compare sum methods

test_post_hate_calc <- data_hate_scored %>%
  select(response_id, starts_with("post_self_hate_") & -contains("tim")) %>%
  mutate(post_manual_mean = rowMeans(select(., post_self_hate_1, post_self_hate_2, post_self_hate_3), na.rm = TRUE)) %>%
  mutate(across(contains("manual"), ~ case_when(is.nan(.) ~ NA_real_, # Replace NaN with NA
                                        TRUE ~ .))) %>% # Keep other values unchanged
  select(post_self_hate_mean, post_manual_mean)

```

Checking pre and post hate means are identical across averaging methods

```{r pre hate scoring validation, validate = TRUE}

test_pre_hate_calc %>%
  pointblank::col_vals_equal(vars(pre_self_hate_mean), 
                             vars(pre_manual_mean), 
                             na_pass = TRUE) # passes if means are identical across methods

```

```{r post hate scoring validation, validate = TRUE}

test_post_hate_calc %>%
  pointblank::col_vals_equal(vars(post_self_hate_mean), 
                             vars(post_manual_mean), 
                             na_pass = TRUE) # passes if means are identical across methods

```

### PFS

Calculating program feedback scores using the Program feedback scale (measured post SSI). Row mean scores range from 1 to 5, where 1 = really disagree, and 5 = really agree. Source: https://mental.jmir.org/2020/6/e20513

```{r pulling pfs values, include=FALSE}

## Pulling pfs variables

# vars_pfs <- data_hate_scored %>%
#   select(contains("pfs") & -contains("like") & 
#            -contains("change") & 
#            -contains("more") &
#            -contains("tim")) %>%
#   head() %>%
#   print()

```

Mutating pfs character values to numeric values

```{r mutating pfs values}

## Mutating character values to numeric across multiple pfs columns 

data_pfs_mutated <- data_hate_scored %>%
  mutate(across(contains("pfs_") & -contains("like") & 
               -contains("change") &
               -contains("more") &
               -contains("tim"),
                ~ case_when(
                    . == "Really Disagree" ~ 1,
                    . == "Disagree" ~ 2,
                    . == "Neutral" ~ 3,
                    . == "Agree" ~ 4,
                    . == "Really Agree" ~ 5,
                    TRUE ~ NA_real_ # Handle other cases with NA
                )))
 
```

Checking pfs variables are now numeric class

```{r pfs numeric class check}

## Checking that all pfs vars are numeric class

data_pfs_mutated %>%
  select(contains("pfs") & 
         -contains("like") & 
         -contains("change") &
         -contains("more") &
         -contains("tim"),) %>%
  summarise(across(everything(), ~ class(.x)[1])) %>%
  tidyr::pivot_longer(cols = everything(), names_to = "variable", values_to = "class")


```

```{r using function to setup pfs mutation check, include=FALSE}

# `data_hate_scored` is the pre-mutation dataframe
# and `data_pfs_mutated` is the post-mutation dataframe,
# and we want to compare the value counts of "pfs_1":

test_mutate <- prep_mutation_check(data_hate_scored, data_pfs_mutated, "pfs_1")

```

Checking pfs response counts are identical from pre to post mutation

```{r pfs response counts validation, validate = TRUE}

test_mutate %>%
  pointblank::col_vals_equal(vars(count_pre), 
                             vars(count_post)) # passes if response counts are identical pre to post mutation

```

Calculating pfs row means

```{r calculating pfs scores}

## Calculating composite scores

data_pfs_scored <- data_pfs_mutated %>%
  # Calculate the row means of relevant pfs_ columns, excluding specific patterns
  mutate(pfs_mean = rowMeans(across(contains("pfs_") & 
                                    !contains("like") & 
                                    !contains("change") &
                                    !contains("more") &
                                    !contains("tim")), na.rm = TRUE)) %>%
  # Replace NaN values with NA_real_ across relevant pfs columns
  mutate(across(contains("pfs_") &
                !contains("like") & 
                !contains("change") &
                !contains("more") &
                !contains("tim"),
                ~ case_when(is.nan(.x) ~ NA_real_,  # Replace NaN with NA
                            TRUE ~ .x))) # Keep other values unchanged

```

```{r checking hate score setup, include = FALSE}

## checking composite calculation was correct

# manually calculating totals to compare sum methods

test_pfs_calc <- data_pfs_scored %>%
  select(response_id, starts_with("pfs") & 
                                    !contains("like") & 
                                    !contains("change") &
                                    !contains("more") &
                                    !contains("tim")) %>%
  mutate(manual_mean = rowMeans(select(., pfs_1, pfs_2, pfs_3, pfs_4, pfs_5, pfs_6, pfs_7), na.rm = TRUE)) %>%
  mutate(across(contains("manual"), ~ case_when(is.nan(.) ~ NA_real_, # Replace NaN with NA
                                        TRUE ~ .))) %>% # Keep other values unchanged
  select(pfs_mean, manual_mean)

```

Checking pfs mean is identical across averaging methods

```{r pfs scoring validation, validate = TRUE}

test_pfs_calc %>%
  pointblank::col_vals_equal(vars(pfs_mean), 
                             vars(manual_mean), 
                             na_pass = TRUE) # passes if totals are identical across sum methods

```
