---
title: "YES English Report"
author: "Mallory Dobias"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    toc: yes
    toc_depth: 5
    toc_float:
      collapsed: no
      smooth_scroll: no
  pdf_document:
    toc: yes
    toc_depth: '5'
  word_document:
    toc: yes
    toc_depth: '5'
geometry: margin=0.50in
---

```{r setup, include=FALSE}

## Setting up R

knitr::opts_chunk$set(echo = TRUE)

if(!require(pointblank)){install.packages('pointblank')}
library(pointblank) # installing and calling pointblank package early in Markdown

validate_rmd(summary = TRUE, log_to_file = FALSE) # allowing validation from pointblank package within Markdown

```

```{r packages, include=FALSE}

## Loading packages

if(!require(here)){install.packages('here')}
library(here)

if(!require(dplyr)){install.packages('dplyr')}
library(dplyr)

if(!require(stringr)){install.packages('stringr')}
library(stringr)

if(!require(tidyr)){install.packages('tidyr')}
library(tidyr)

if(!require(readr)){install.packages('readr')}
library(readr)

if(!require(tidyverse)){install.packages('tidyverse')}
library(tidyverse)

if(!require(showtext)){install.packages('showtext')}
library(showtext)

if(!require(patchwork)){install.packages('patchwork')}
library(patchwork)

if(!require(stats)){install.packages('stats')}
library(stats)

if(!require(MOTE)){install.packages('MOTE')}
library(MOTE)

if(!require(rempsyc)){install.packages('rempsyc')}
library(rempsyc)

if(!require(rmarkdown)){install.packages('rmarkdown')}
library(rmarkdown)

if(!require(officer)){install.packages('officer')}
library(officer)

if(!require(flextable)){install.packages('flextable')}
library(flextable)

if(!require(ggridges)){install.packages('ggridges')}
library(ggridges)

if(!require(ggplot2)){install.packages('ggplot2')}
library(ggplot2)

```

```{r note, include=FALSE}

## The next several chunks setup the data for our analysis and 
## calculate values that are required for the summary

```

```{r reading in data, include=FALSE}

## Reading in cleaned survey data

library(here) # places working directory at root of project folder

data <- readRDS(here("data", "clean", "yes_data_english_clean.Rds")) # directing to data from project folder root

# head(data) # looks good

```

```{r filtering to youth only data for analysis, include=FALSE}

## Filtering to youth only for our analysis

data_youth <- data %>%
  filter(dem_age != "18 or older" &
         dem_age != "17 or older" &
         dem_age != "16-20" &
         dem_age != "21-25" &   
         dem_age != "26-30" & 
         dem_age != "31-35" &  
         dem_age != "36-40" & 
         dem_age != "41-45" & 
         dem_age != "46-50" & 
         dem_age != "51-55" & 
         dem_age != "56-60" & 
         dem_age != "61-65" & 
         dem_age != "66-70" & 
         dem_age != "71-75" & 
         dem_age != "76-80" &
         dem_age != "81-85" &
         dem_age != "86-90" &
         dem_age != "91-95" &
         dem_age != "96-100" &
         dem_age != "101 or older")

## Checking that all dfs have values in this column (d03 not present because no age item)

data_youth %>%
  select(data_id, dem_age) %>%
  filter(!is.na(dem_age)) %>%
  group_by(data_id) %>%
  tally()

## Checking that data come from youth

data_youth %>%
  select(data_id, dem_age) %>%
  group_by(dem_age) %>%
  tally()

```

```{r calculating n milestones, include=FALSE}

## Calculating n milestones

n_started_survey <- data_youth %>%
  tally() # started the survey

n_chose_any_ssi <- data_youth %>%
  filter(!is.na(ssi_choice)) %>%
  tally() # chose any ssi

n_chose_abc <- data_youth %>%
  filter(str_detect(ssi_choice, "ABC")) %>%
  tally() # chose abc

n_chose_care <- data_youth %>%
  filter(str_detect(ssi_choice, "CARE")) %>%
  tally() # chose care
  
n_chose_pp <- data_youth %>%
  filter(str_detect(ssi_choice, "Personality")) %>%
  tally() # chose pp

n_chose_rise <- data_youth %>%
  filter(str_detect(ssi_choice, "RISE")) %>%
  tally() # chose pp

## Checking that all dfs have values in the ssi_choice column (d03 not present because no age item)

data_youth %>%
  select(data_id, ssi_choice) %>%
  filter(!is.na(ssi_choice)) %>%
  group_by(data_id) %>%
  tally()

```

```{r calculating perc milestones, include=FALSE}

## Percent of cases who chose an ssi, of those who started the survey

perc_chose_any_ssi <- round((n_chose_any_ssi/n_started_survey)*100, 2)

## Percent of cases who chose abc, of those who chose any ssi

perc_chose_abc <- round((n_chose_abc/n_chose_any_ssi)*100, 2)

## Percent of cases who chose care, of those who chose any ssi

perc_chose_care <- round((n_chose_care/n_chose_any_ssi)*100, 2)

## Percent of cases who chose pp, of those who chose any ssi

perc_chose_pp <- round((n_chose_pp/n_chose_any_ssi)*100, 2)

## Percent of cases who chose pp, of those who chose any ssi

perc_chose_rise <- round((n_chose_rise/n_chose_any_ssi)*100, 2)

```

```{r calculating perc complete of those who started for abc, include=FALSE}

n_started_abc <- data_youth %>%
  filter(str_detect(ssi_choice, "ABC")) %>% # filtering to those who chose this ssi
  filter(!is.na(ssi_started)) %>% # filtering to those who started an ssi
  select(ssi_choice, ssi_started) %>%
  tally()

n_completed_abc <- data_youth %>%
  filter(str_detect(ssi_choice, "ABC")) %>% # filtering to those who chose this ssi
  filter(!is.na(ssi_completed)) %>% # filtering to those who started an ssi
  select(ssi_choice, ssi_completed) %>%
  tally()

perc_completed_abc <- round((n_completed_abc / n_started_abc) * 100, 2)

## Checking that all dfs have values in these columns (d03 not present because no age item)

data_youth %>%
  select(data_id, ssi_started) %>%
  filter(!is.na(ssi_started)) %>%
  group_by(data_id) %>%
  tally()

data_youth %>%
  select(data_id, ssi_completed) %>%
  filter(!is.na(ssi_completed)) %>%
  group_by(data_id) %>%
  tally()

# data %>%
#   filter(data_id == "d05") %>%
#   select(data_id, ssi_completed, dem_age) # d05 has no ssi_started responses from youth

```

```{r writing custom function for perc completed ssi, include=FALSE}

# Define the custom function
filter_and_summarize_ssi <- function(data, filter_string, started_var_name, completed_var_name) {
  # Filter for those who started the SSI and assign globally
  assign(started_var_name, data %>%
           filter(str_detect(ssi_choice, filter_string)) %>%
           filter(!is.na(ssi_started)) %>%
           tally(), envir = .GlobalEnv)
  
  # Filter for those who completed the SSI and save variables to global environment
  assign(completed_var_name, data %>%
           filter(str_detect(ssi_choice, filter_string)) %>%
           filter(!is.na(ssi_completed)) %>%
           tally(), envir = .GlobalEnv)
  
  # Calculate percentage completed and save variables to global environment
  perc_completed_name <- paste0("perc_completed_", tolower(gsub("\\.", "", filter_string)))
  assign(perc_completed_name, round((get(completed_var_name, envir = .GlobalEnv) / get(started_var_name, envir = .GlobalEnv)) * 100, 2), envir = .GlobalEnv)
  
  # Return the results as a list
  list(
    started = get(started_var_name, envir = .GlobalEnv),
    completed = get(completed_var_name, envir = .GlobalEnv),
    perc_completed = get(perc_completed_name, envir = .GlobalEnv)
  )
}

```

```{r using custom function for perc completed abc, include=FALSE}

# Testing custom function for perc completion on abc
results <- filter_and_summarize_ssi(data_youth, "ABC", "n_started_abc", "n_completed_abc")
print(results)

# Later, you can access n_started_abc, n_completed_abc, and perc_completed_abc from the global environment:
print(n_started_abc)
print(n_completed_abc)
print(perc_completed_abc)

```

```{r using custom function for perc completed care, include=FALSE}

# Testing custom function for perc completion on care
results <- filter_and_summarize_ssi(data_youth, "CARE", "n_started_care", "n_completed_care")
print(results)

# Later, you can access these vars from the global environment:
print(n_started_care)
print(n_completed_care)
print(perc_completed_care)

```

```{r using custom function for perc completed pp, include=FALSE}

# Testing custom function for perc completion on pp
results <- filter_and_summarize_ssi(data_youth, "Personality", "n_started_pp", "n_completed_pp")
print(results)

# Later, you can access these vars from the global environment:
print(n_started_pp)
print(n_completed_pp)
print(perc_completed_personality)

```

```{r using custom function for perc completed rise, include=FALSE}

# Testing custom function for perc completion on rise
results <- filter_and_summarize_ssi(data_youth, "RISE", "n_started_rise", "n_completed_rise")
print(results)

# Later, you can access these vars from the global environment:
print(n_started_rise)
print(n_completed_rise)
print(perc_completed_rise)

```

```{r calculating perc complete of those who started any ssi, include=FALSE}

n_started_any_ssi <- data_youth %>%
  filter(!is.na(ssi_started)) %>% # filtering to those who started an ssi
  select(ssi_choice, ssi_started) %>%
  tally()

n_completed_any_ssi <- data_youth %>%
  filter(!is.na(ssi_completed)) %>% # filtering to those who started an ssi
  select(ssi_choice, ssi_completed) %>%
  tally()

perc_completed_any_ssi <- round((n_completed_any_ssi / n_started_any_ssi) * 100, 2)

```

```{r calculating perc agreed to questionnaires, include=FALSE}

n_agreed_questionnaires <- data_youth %>%
  filter(volunteer_questionnaires_yn == "Yes") %>% # filtering to those who agreed
  select(volunteer_questionnaires_yn) %>%
  tally()

n_answered_questionnaires_item <- data_youth %>%
  filter(!is.na(volunteer_questionnaires_yn)) %>% # filtering to those who answered the question
  select(volunteer_questionnaires_yn) %>%
  tally()

perc_agreed_questionnaires <- round((n_agreed_questionnaires / n_answered_questionnaires_item) * 100, 2) # percent agreed, of those who were asked

## Checking that all dfs have values in this columns (d03 not present because no age item, d02 does not have volunteer item)

data_youth %>%
  select(data_id, volunteer_questionnaires_yn) %>%
  filter(!is.na(volunteer_questionnaires_yn)) %>%
  group_by(data_id) %>%
  tally()

```

```{r calculating aggregated pfs mean overall, include=FALSE}

## Calculating overall pfs mean, across all ssis

m_pfs_overall <- round(mean(data_youth$pfs_mean, na.rm = TRUE), 2)

## Checking that all dfs have values in this column (d03 no age var, d16 has no completers yet, d05 has no youth post-responses)

data_youth %>%
  select(data_id, pfs_mean) %>%
  filter(!is.na(pfs_mean)) %>%
  group_by(data_id) %>%
  tally()

```

```{r calculating aggregated pfs mean for abc, include=FALSE}

## Pulling only abc responses

data_youth_abc <- data_youth %>%
  filter(str_detect(ssi_choice, "ABC")) # filtering to those who chose abc

## Calculating overall pfs mean for abc

m_pfs_abc <- round(mean(data_youth_abc$pfs_mean, na.rm = TRUE), 2)

```

```{r calculating aggregated pfs mean for care, include=FALSE}

## Pulling only care responses

data_youth_care <- data_youth %>%
  filter(str_detect(ssi_choice, "CARE")) # filtering to those who chose care

## Calculating overall pfs mean for care

m_pfs_care <- round(mean(data_youth_care$pfs_mean, na.rm = TRUE), 2)

```

```{r calculating aggregated pfs mean for pp, include=FALSE}

## Pulling only pp responses

data_youth_pp <- data_youth %>%
  filter(str_detect(ssi_choice, "Personality")) # filtering to those who chose pp

## Calculating overall pfs mean for pp

m_pfs_pp <- round(mean(data_youth_pp$pfs_mean, na.rm = TRUE), 2)

```

```{r calculating aggregated pfs mean for rise, include=FALSE}

## Pulling only rise responses

data_youth_rise <- data_youth %>%
  filter(str_detect(ssi_choice, "RISE")) # filtering to those who chose rise

## Calculating overall pfs mean for rise

m_pfs_rise <- round(mean(data_youth_rise$pfs_mean, na.rm = TRUE), 2)

```

```{r t test bhs abc, include=FALSE}

## Trying this once before writing a function

library(stats)

## Computing paired t-test

t_abc_bhs <- t.test(data_youth_abc$post_bhs_mean, data_youth_abc$pre_bhs_mean, paired = TRUE)

## Saving p-value for report

abc_bhs_p_value <- t_abc_bhs$p.value

## Saving t-value for effect size calc

abc_bhs_t_value <- t_abc_bhs$statistic

## Saving n pairs for effect size calc

abc_bhs_n_pairs <- data_youth_abc %>%
  filter(!is.na(post_bhs_mean) & !is.na(pre_bhs_mean)) %>%
  select(post_bhs_mean, pre_bhs_mean) %>%
  nrow()

## Checking that all dfs have values in these columns (d03 no age var, d16 has no completers yet, d05 has no youth post-responses)

data_youth %>%
  select(data_id, pre_bhs_mean) %>%
  filter(!is.na(pre_bhs_mean)) %>%
  group_by(data_id) %>%
  tally()

data_youth %>%
  select(data_id, post_bhs_mean) %>%
  filter(!is.na(post_bhs_mean)) %>%
  group_by(data_id) %>%
  tally()

```

```{r t test effect size bhs abc, include=FALSE}

library(MOTE)

##  Calculating dz effect size, paired t-test

abc_bhs_dz_value <- round(d.dep.t.diff.t(abc_bhs_t_value, abc_bhs_n_pairs, a = 0.05)$d, 2)

```

```{r t test shs abc, include=FALSE}

library(stats)

## Computing paired t-test

t_abc_shs <- t.test(data_youth_abc$post_shs_mean, data_youth_abc$pre_shs_mean, paired = TRUE)

## Saving p-value for report

abc_shs_p_value <- t_abc_shs$p.value

## Saving t-value for effect size calc

abc_shs_t_value <- t_abc_shs$statistic

## Saving n pairs for effect size calc 

abc_shs_n_pairs <- data_youth_abc %>%
  filter(!is.na(post_shs_mean) & !is.na(pre_shs_mean)) %>%
  select(post_shs_mean, pre_shs_mean) %>%
  nrow()

## Checking that all dfs have values in these columns (d03 no age var, d16 has no completers yet, d05 has no youth post-responses)

data_youth %>%
  select(data_id, pre_shs_mean) %>%
  filter(!is.na(pre_shs_mean)) %>%
  group_by(data_id) %>%
  tally()

data_youth %>%
  select(data_id, post_shs_mean) %>%
  filter(!is.na(post_shs_mean)) %>%
  group_by(data_id) %>%
  tally()

```

```{r t test effect size shs abc, include=FALSE}

library(MOTE)

##  Calculating dz effect size, paired t-test

abc_shs_dz_value <- round(d.dep.t.diff.t(abc_shs_t_value, abc_shs_n_pairs, a = 0.05)$d, 2)

```

```{r t test hate abc, include=FALSE}

library(stats)

## Computing paired t-test

t_abc_hate <- t.test(data_youth_abc$post_self_hate_mean, data_youth_abc$pre_self_hate_mean, paired = TRUE)

## Saving p-value for report

abc_hate_p_value <- t_abc_hate$p.value

## Saving t-value for effect size calc

abc_hate_t_value <- t_abc_hate$statistic

## Saving n pairs for effect size calc 

abc_hate_n_pairs <- data_youth_abc %>%
  filter(!is.na(post_self_hate_mean) & !is.na(pre_self_hate_mean)) %>%
  select(post_self_hate_mean, pre_self_hate_mean) %>%
  nrow()

## Checking that all dfs have values in these columns (d03 no age var, d16 has no completers yet, d05 has no youth post-responses)

data_youth %>%
  select(data_id, pre_self_hate_mean) %>%
  filter(!is.na(pre_self_hate_mean)) %>%
  group_by(data_id) %>%
  tally()

data_youth %>%
  select(data_id, post_self_hate_mean) %>%
  filter(!is.na(post_self_hate_mean)) %>%
  group_by(data_id) %>%
  tally()

```

```{r t test effect size hate abc, include=FALSE}

library(MOTE)

##  Calculating dz effect size, paired t-test

abc_hate_dz_value <- round(d.dep.t.diff.t(abc_hate_t_value, abc_hate_n_pairs, a = 0.05)$d, 2)

```

```{r abc effect sizes list, include=FALSE}

## Saving dz values for report

abc_dz_values <- c(abc_bhs_dz_value, abc_shs_dz_value, abc_hate_dz_value)

```

```{r writing custom paired t-test function, include=FALSE}

library(tidyverse)
library(MOTE)
library(stats)

# Define the custom function
run_paired_t_test <- function(data, pre_col, post_col, prefix) {
  
  # Construct variable names dynamically for storage in global environment
  t_test_name <- paste0("t_", prefix)
  p_value_name <- paste0(prefix, "_p_value")
  t_value_name <- paste0(prefix, "_t_value")
  n_pairs_name <- paste0(prefix, "_n_pairs")
  dz_value_name <- paste0(prefix, "_dz_value")
  
  # Conduct the paired t-test
  t_test_result <- t.test(data[[post_col]], data[[pre_col]], paired = TRUE)
  
  # Save t-test results globally
  assign(t_test_name, t_test_result, envir = .GlobalEnv)
  
  # Save p-value and t-value globally
  assign(p_value_name, t_test_result$p.value, envir = .GlobalEnv)
  assign(t_value_name, t_test_result$statistic, envir = .GlobalEnv)
  
  # Calculate number of valid pairs (non-NA values in both columns)
  n_pairs <- data %>%
    filter(!is.na(.[[post_col]]) & !is.na(.[[pre_col]])) %>%
    nrow()
  assign(n_pairs_name, n_pairs, envir = .GlobalEnv)
  
  # Calculate the effect size (dz) and save it globally
  dz_value <- round(d.dep.t.diff.t(t_test_result$statistic, n_pairs, a = 0.05)$d, 2)
  assign(dz_value_name, dz_value, envir = .GlobalEnv)
  
  # Return a list of the calculated values
  return(list(
    t_test_result = get(t_test_name),
    p_value = get(p_value_name),
    t_value = get(t_value_name),
    n_pairs = get(n_pairs_name),
    dz_value = get(dz_value_name)
  ))
}

```

```{r running t tests for abc using custom function, include=FALSE}

# BHS
results_bhs <- run_paired_t_test(data_youth_abc, "pre_bhs_mean", "post_bhs_mean", "abc_bhs")
print(results_bhs)

# SHS
results_shs <- run_paired_t_test(data_youth_abc, "pre_shs_mean", "post_shs_mean", "abc_shs")
print(results_shs)

# Self-hate
results_hate <- run_paired_t_test(data_youth_abc, "pre_self_hate_mean", "post_self_hate_mean", "abc_hate")
print(results_hate)

# Combine all dz values into a single vector for reporting
abc_dz_values <- c(abc_bhs_dz_value, abc_shs_dz_value, abc_hate_dz_value)
print(abc_dz_values)

```

```{r running t tests for care using custom function, include=FALSE}

# BHS
results_bhs <- run_paired_t_test(data_youth_care, "pre_bhs_mean", "post_bhs_mean", "care_bhs")
print(results_bhs)

# SHS
results_shs <- run_paired_t_test(data_youth_care, "pre_shs_mean", "post_shs_mean", "care_shs")
print(results_shs)

# Self-hate
results_hate <- run_paired_t_test(data_youth_care, "pre_self_hate_mean", "post_self_hate_mean", "care_hate")
print(results_hate)

# Combine all dz values into a single vector for reporting
care_dz_values <- c(care_bhs_dz_value, care_shs_dz_value, care_hate_dz_value) # not including non-significant outcome results
print(care_dz_values)

```

```{r running t tests for pp using custom function, include=FALSE}

# BHS
results_bhs <- run_paired_t_test(data_youth_pp, "pre_bhs_mean", "post_bhs_mean", "pp_bhs")
print(results_bhs)

# SHS
results_shs <- run_paired_t_test(data_youth_pp, "pre_shs_mean", "post_shs_mean", "pp_shs")
print(results_shs)

# Self-hate
results_hate <- run_paired_t_test(data_youth_pp, "pre_self_hate_mean", "post_self_hate_mean", "pp_hate")
print(results_hate)

# Combine all dz values into a single vector for reporting
pp_dz_values <- c(pp_bhs_dz_value, pp_shs_dz_value, pp_hate_dz_value) # not including non-significant outcome results
print(pp_dz_values)

```

```{r running t tests for rise using custom function, include=FALSE}

# BHS
results_bhs <- run_paired_t_test(data_youth_rise, "pre_bhs_mean", "post_bhs_mean", "rise_bhs")
print(results_bhs)

# SHS
results_shs <- run_paired_t_test(data_youth_rise, "pre_shs_mean", "post_shs_mean", "rise_shs")
print(results_shs)

# Self-hate
results_hate <- run_paired_t_test(data_youth_rise, "pre_self_hate_mean", "post_self_hate_mean", "rise_hate")
print(results_hate)

# Combine all dz values into a single vector for reporting
rise_dz_values <- c(rise_bhs_dz_value, rise_shs_dz_value, rise_hate_dz_value) 
print(rise_dz_values)

```

```{r gender identity differs from sex, include=FALSE}

## Tallying number of cases where gender identity is different from sex assigned at birth

n_gender_differs_from_sex <- data_youth %>%
  filter(dem_gender_diff_sex == "Yes") %>%
  tally()

## Tallying number of cases where gender identity aligns with assigned sex

n_gender_same_as_sex <- data_youth %>%
  filter(dem_gender_diff_sex == "No") %>%
  tally()

## Calculating percentage of these cases, of everyone who started the survey

perc_gender_differs_from_sex <- round((n_gender_differs_from_sex / n_started_survey)*100,2)

perc_gender_same_as_sex <- round((n_gender_same_as_sex / n_started_survey)*100,2)

## Checking that all dfs have values in this column (d03 no age var)

data_youth %>%
  select(data_id, dem_gender_diff_sex) %>%
  filter(!is.na(dem_gender_diff_sex)) %>%
  group_by(data_id) %>%
  tally()

```

```{r perc sexual minority, include=FALSE}

## Tallying number of cases where gender identity is different from sex assigned at birth

n_sex_minority <- data_youth %>%
  select(dem_sex_orientation) %>%
  filter(!is.na(dem_sex_orientation) & 
           dem_sex_orientation != "Heterosexual/Straight" &
           dem_sex_orientation != "I do not want to respond") %>%
  tally()

## Tallying n straight folks

n_sex_straight <- data_youth %>%
  select(dem_sex_orientation) %>%
  filter(dem_sex_orientation == "Heterosexual/Straight") %>%
  tally()

## Calculating percentage of these cases, of everyone who started the survey

perc_sex_minority <- round((n_sex_minority / n_started_survey)*100,2)

perc_sex_straight <- round((n_sex_straight / n_started_survey)*100,2)

## Checking that all dfs have values in this column (d03 no age var)

data_youth %>%
  select(data_id, dem_sex_orientation) %>%
  filter(!is.na(dem_sex_orientation)) %>%
  group_by(data_id) %>%
  tally()

```

```{r perc racial minority, include=FALSE}

## Tallying number of cases where racial identity is not white or missing

n_racial_minority <- data_youth %>%
  select(contains("dem_race"), -contains("white"), -contains("hisp")) %>%
  filter(if_any(c(dem_race_asian, dem_race_black, dem_race_other), ~ . == "yes")) %>%
  tally()

## Tallying number of cases where ethnic identity is latine/hispanic

n_racial_latine_hisp <- data_youth %>%
  filter(dem_race_latin_hisp == "yes") %>%
  tally()

## Tallying number of cases where racial identity is white

n_racial_white <- data_youth %>%
  filter(dem_race_white == "yes") %>%
  tally()

## Calculating percentage of these cases, of everyone who started the survey

perc_racial_minority <- round((n_racial_minority / n_started_survey)*100,2)

perc_racial_latine_hisp <- round((n_racial_latine_hisp / n_started_survey)*100,2)

perc_racial_white <- round((n_racial_white / n_started_survey)*100,2)

## Checking that all dfs have values in this column (d03 no dem vars, d05 contains middle east specific ethnicity items)

data_youth %>%
  select(data_id, dem_race_white) %>%
  filter(!is.na(dem_race_white)) %>%
  group_by(data_id) %>%
  tally()

```

```{r, out.width = "350px", out.height = "290px", include=TRUE, echo=FALSE}

knitr::include_graphics("/Users/mallorydobias/Documents/R/yes_project/images/yes_lsmh_graphic.png")

```

# Summary

**Executive Summary**: This report uses youth data (under 18) from all English-speaking YES surveys (data_ids: d01, d02, d03, d09, d16). SSIs are completed ~40-50% of the time they are started. Clinical outcomes (e.g., hopelessness, agency, self-hate) improve from before to after finishing an SSI. SSIs receive ratings between 3 and 4 out of 5, where 5 is the highest approval rating. Lots of drop-off happens when SSIs introduce writing exercises.

**Full Summary**:

Looking at YES engagement:

+ Our YES survey was started `r n_started_survey` times
+ In `r perc_agreed_questionnaires`% of cases, youth agreed to complete optional questionnaires when asked
+ Not all cases were asked if they would like to complete questionnaires (e.g., San Antonio data)
+ `r perc_chose_any_ssi`% of cases chose an SSI (n = `r n_chose_any_ssi`) 

Across all survey starts (n = `r n_started_survey`):

+ There's lots of missing demographic data, given optional questionnaires and drop-offs
+ Ages range from <10 to 17 (categorical data only)
+ `r perc_gender_differs_from_sex`% endorse a gender identity that differs from sex assigned at birth (`r perc_gender_same_as_sex`% cis)
+ `r perc_sex_minority`% endorse a sexual orientation other than heterosexual (`r perc_sex_straight`% heterosexual)
+ Race and ethnicity are measured differently across surveys (see below)

Of cases with data at both time points:

+ Hopelessness decreased, agency increased, and self-hate decreased pre to post ABC (dzs = `r abc_dz_values`)
+ Hopelessness decreased, agency increased, and self-hate decreased pre to post CARE (dzs = `r care_dz_values`)
+ Hopelessness decreased, agency increased, and self-hate decreased pre to post Project Personality (dzs = `r pp_dz_values`)
+ Significance tests could not be run for RISE, given small n (e.g., df = `r d.dep.t.diff.t(rise_hate_t_value, rise_hate_n_pairs, a = 0.05)$df`)

Of the cases where someone chose an SSI:

+ `r perc_chose_abc`% chose ABC
+ `r perc_chose_care`% chose CARE
+ `r perc_chose_pp`% chose Project Personality
+ `r perc_chose_rise`% chose RISE, although this ssi was likely added to the survey later

Of cases where someone started an SSI:

+ `r perc_completed_any_ssi`% of cases completed an SSI (n = `r n_completed_any_ssi`) after starting one (n = `r n_started_any_ssi`)
+ `r perc_completed_abc`% of cases completed ABC (n = `r n_completed_abc`) after starting it (n = `r n_started_abc`)
+ `r perc_completed_care`% of cases completed CARE (n = `r n_completed_care`) after starting it (n = `r n_started_care`)
+ `r perc_completed_personality`% of cases completed Project Personality (n = `r n_completed_pp`) after starting it (n = `r n_started_pp`)
+ `r perc_completed_rise`% of cases completed RISE (n = `r n_completed_rise`) after starting it (n = `r n_started_rise`)

Drop-off is highest on pages with writing exercises:

+ More than 1 in 4 people drop from one page to the next during Project Personality's first writing exercise

Youth gave SSIs an overall rating of `r m_pfs_overall` out of 5:

+ ABC received an overall acceptability rating of `r m_pfs_abc` out of 5.
+ CARE received an overall acceptability rating of `r m_pfs_care` out of 5.
+ Project Personality received an overall acceptability rating of `r m_pfs_pp` out of 5.
+ RISE received an overall acceptability rating of `r m_pfs_rise` out of 5.

# Questionnaire Completion

More than half of the time (`r perc_agreed_questionnaires`%, n = `r n_agreed_questionnaires`), youth agreed to fill out optional questionnaires when asked. 

```{r perc agreed questionnaires}

perc_agreed_questionnaires

```

# Demographics

## Data Source

N's and percentages are all calculated out of the number of total youth responses.

```{r prepping for data tally, include=FALSE}

data_youth_data_source <- data_youth %>%
  select(data_id)

```

```{r calculating data tally, include=FALSE}

## Prepping dataframe with data tallies; renaming is a bit weird here once % is calculated
## No need to add missing values here, since only one variable

data_source_tallies <- data_youth_data_source %>%
  group_by(data_id) %>%
  tally() %>%
  ungroup() %>%
  rename(count = n) %>%
  rowwise() %>%
  mutate(percentage = count / nrow(data_youth_data_source) * 100) %>%
  mutate(percentage = round(percentage, 2)) %>%
  unnest(cols = c(percentage)) %>%
  rename(n = count, "%" = percentage)

```

```{r printing data tally, include=TRUE}

rempsyc::nice_table(data_source_tallies)

```

## Age

N's and percentages are all calculated out of the number of survey starts from youth (n = `r n_started_survey`). 

```{r prepping for age tally, include=FALSE}

data_youth_age <- data_youth %>%
  select(dem_age)

```

```{r calculating age tally, include=FALSE}

## Prepping dataframe with age tallies; renaming is a bit weird here once % is calculated
## No need to add missing values here, since only one variable

age_tallies <- data_youth_age %>%
  select(age = dem_age) %>%
  group_by(age) %>%
  tally() %>%
  ungroup() %>%
  rename(count = n) %>%
  rowwise() %>%
  mutate(percentage = count / n_started_survey * 100) %>%
  mutate(percentage = round(percentage, 2)) %>%
  unnest(cols = c(percentage)) %>%
  rename(n = count, "%" = n)

```

```{r printing age tally, include=TRUE}

rempsyc::nice_table(age_tallies)

```

## Gender

`r perc_gender_differs_from_sex`% of survey responses endorsed a gender identity that differs from sex assigned at birth. N's and percentages are all calculated out of the number of survey starts from youth (n = `r n_started_survey`). 

```{r combining sex and gender data, include=FALSE}

## Imputing gender identity data for folks who answered gender does not differ from sex
## Only folks who reported gender differs from sex were asked gender identity item

data_youth_gender <- data_youth %>%
  mutate(dem_gender_girl_woman = case_when(dem_gender_diff_sex == "No" & dem_sex == "Female" ~ "yes",
         TRUE ~ dem_gender_girl_woman)) %>%
  mutate(dem_gender_boy_man = case_when(dem_gender_diff_sex == "No" & dem_sex == "Male" ~ "yes",
         TRUE ~ dem_gender_boy_man)) %>%
  mutate(dem_gender_intersex = case_when(dem_gender_diff_sex == "No" & dem_sex == "Intersex" ~ "yes",
         TRUE ~ dem_gender_intersex)) %>%
  select(contains("gender"), -dem_gender_other_text, -dem_gender_diff_sex) %>%
  mutate(dem_gender_missing = case_when(
    if_all(everything(), is.na) ~ "yes",  # "yes" if all gender vars are NA mark as missing
    TRUE ~ "no"  # Otherwise, mark as "no"
  ))

```

```{r custom demographic count function, include=FALSE}

# Custom function to tally yeses in each demographic column 

count_yes_responses <- function(data) {
  # Ensure n_agreed_questionnaires exists in the global environment
  if (!exists("n_agreed_questionnaires", envir = .GlobalEnv)) {
    stop("n_agreed_questionnaires is not defined in the global environment")
  }
  
  data %>%
    summarise(across(everything(), ~ sum(. == "yes" | . == "Yes", na.rm = TRUE))) %>% # Count "yes" in each column
    pivot_longer(cols = everything(), # Convert to long format
                 names_to = "variable", 
                 values_to = "count") %>%
    rowwise() %>%
    mutate(percentage = count / n_started_survey * 100) %>% 
    mutate(percentage = round(percentage, 2)) %>% # Correct rounding
    unnest(cols = c(percentage))  # Ensure percentage column is not nested
}

```

```{r calculating gender tally, include=FALSE}

# Using custom function to print gender variable counts

gender_tallies <- count_yes_responses(data_youth_gender) %>%
  mutate(variable = str_replace(variable, "dem_gender_", "")) %>%
  rename(gender_identity = variable) %>%
  rename("%" = n) %>%
  rename(n = count) %>%
  mutate(gender_identity = str_replace(gender_identity, "girl_woman", "Girl/Woman"),
         gender_identity = str_replace(gender_identity, "boy_man", "Boy/Man"),
         gender_identity = str_replace(gender_identity, "missing", "Missing"),
         gender_identity = str_replace(gender_identity, "nonbinary", "Nonbinary"),
         gender_identity = str_replace(gender_identity, "unsure", "Unsure"),
         gender_identity = str_replace(gender_identity, "other", "Another gender not listed"),
         gender_identity = str_replace(gender_identity, "ftm_trans", "Female to male trans/FTM"),
         gender_identity = str_replace(gender_identity, "trans", "Transgender"),
         gender_identity = str_replace(gender_identity, "genderqueer", "Genderqueer"),
         gender_identity = str_replace(gender_identity, "androgynous", "Androgynous"),
         gender_identity = str_replace(gender_identity, "agender", "Agender"),
         gender_identity = str_replace(gender_identity, "Transgender_masc", "Trans masculine"),
         gender_identity = str_replace(gender_identity, "two_spirited", "Two-spirited"),
         gender_identity = str_replace(gender_identity, "third_gender", "Third gender"),
         gender_identity = str_replace(gender_identity, "intersex", "Intersex"),
         gender_identity = str_replace(gender_identity, "expansive", "Gender expansive"),
         gender_identity = str_replace(gender_identity, "mtf_Transgender", "Male to female transgender/MTF"),
         gender_identity = str_replace(gender_identity, "Transgender_fem", "Trans feminine")) %>%
  arrange(-n)

```

```{r printing gender tally, include=TRUE}

rempsyc::nice_table(gender_tallies)

```

```{r perc gender differs from sex, include=TRUE}

perc_gender_differs_from_sex

```

## Sexual Orientation

`r perc_sex_minority`% of survey responses endorsed a sexual orientation other than heterosexual. N's and percentages are all calculated out of the number of survey starts (n = `r n_started_survey`). 

```{r calculating sex orientation tallies, include=FALSE}

## Prepping dataframe with sexual orientation tallies; renaming is a bit weird here once % is calculated
## No need to add missing values here, since only one variable

sex_orientation_tallies <- data_youth %>%
  select(sex_orientation = dem_sex_orientation) %>%
  mutate(sex_orientation = case_when(is.na(sex_orientation) ~ "Missing",
                                     TRUE ~ sex_orientation)) %>%
  group_by(sex_orientation) %>%
  tally() %>%
  ungroup() %>%
  arrange(-n) %>%
  rename(count = n) %>%
  rowwise() %>%
  mutate(percentage = count / n_started_survey * 100) %>%
  mutate(percentage = round(percentage, 2)) %>%
  unnest(cols = c(percentage)) %>%
  rename(n = count, "%" = n)

table(data_youth$dem_sex_orientation)

```

```{r printing sex orientation tally, include=TRUE}

rempsyc::nice_table(sex_orientation_tallies)

```

```{r printing perc sexual minority, include=TRUE}

perc_sex_minority

```

## Race/Ethnicity

```{r adding missing values to race vars, include=FALSE}

## Accounting for missing values across all race variables

data_youth_race <- data_youth %>%
  filter(data_id != "d05") %>% # not counting d05 responses as missing data
  select(contains("race")) %>%
  mutate(dem_race_missing = case_when(
    if_all(everything(), is.na) ~ "yes",  # "yes" if all vars are NA mark as missing
    TRUE ~ "no"  # Otherwise, mark as "no"
  ))

```

```{r calculating race denominator, include=FALSE}

# saving custom denominator value

n_race_denominator <- nrow(data_youth_race)

```

N's and percentages are all calculated out of the number of survey starts, among responses that do not come from d05 (n = `r n_race_denominator`, from d01/d02/d09/d16), given d05 ethnicity is measured differently. Race/ethnicity is not assessed in d03, so these responses are automatically counted as missing.

```{r calculating race tallies, include=FALSE}

## Calculating race tallies

race_tallies <- data_youth_race %>%
  summarise(across(everything(), ~ sum(. == "yes" | . == "Yes", na.rm = TRUE))) %>% # Count "yes" in each column
  pivot_longer(cols = everything(), # Convert to long format
                 names_to = "variable", 
                 values_to = "count") %>%
  rowwise() %>%
  mutate(percentage = count / n_race_denominator * 100) %>% 
  mutate(percentage = round(percentage, 2)) %>% # Correct rounding
  unnest(cols = c(percentage)) %>% # Ensure percentage column is not nested
  mutate(variable = str_replace(variable, "dem_race_", "")) %>%
  rename(racial_ethnic_identity = variable) %>%
  rename(n = count) %>%
  rename("%" = percentage) %>%
  arrange(-n) %>%
  mutate(racial_ethnic_identity = case_when(racial_ethnic_identity == "missing" ~ "Missing",
                                     racial_ethnic_identity == "white" ~ "White",
                                     racial_ethnic_identity == "latin_hisp" ~ "Latine/Hispanic",
                                     racial_ethnic_identity == "asian" ~ "Asian",
                                     racial_ethnic_identity == "black" ~ "Black",
                                     racial_ethnic_identity == "other" ~ "Another racial/ethnic identity not listed",
                                     TRUE ~ racial_ethnic_identity))

```

```{r printing race tally, include=TRUE}

rempsyc::nice_table(race_tallies)

```

```{r adding missing values to ethnicity vars, include=FALSE}

## Accounting for missing values across all race variables

data_youth_ethnicity <- data_youth %>%
  filter(data_id == "d05") %>%
  select(starts_with("dem_ethnicity_") & -contains("text")) %>%
  mutate(dem_ethnicity_missing = case_when(
    if_all(everything(), is.na) ~ "yes",  # "yes" if all vars are NA mark as missing
    TRUE ~ "no"  # Otherwise, mark as "no"
  ))

```

```{r calculating ethnicity denominator, include=FALSE}

# saving custom denominator value

n_ethnicity_denominator <- nrow(data_youth_ethnicity)

```

Now, we'll take a look at ethnicity as measured in d05. (n = `r n_ethnicity_denominator`, from d05 only). These options were only available to responders to the Middle East yes survey.

```{r calculating ethnicity tally, include=FALSE}

# Using custom function to print race variable counts

ethnicity_tallies <- data_youth_ethnicity %>%
  summarise(across(everything(), ~ sum(. == "yes" | . == "Yes", na.rm = TRUE))) %>% # Count "yes" in each column
  pivot_longer(cols = everything(), # Convert to long format
                 names_to = "variable", 
                 values_to = "count") %>%
  rowwise() %>%
  mutate(percentage = (count / n_ethnicity_denominator) * 100) %>% 
  mutate(percentage = round(percentage, 2)) %>% # Correct rounding
  unnest(cols = c(percentage)) %>% # Ensure percentage column is not nested
  mutate(variable = str_replace(variable, "dem_ethnicity_", "")) %>%
  rename(ethnic_identity_middle_east = variable) %>%
  rename(n = count) %>%
  rename("%" = percentage) %>%
  arrange(-n) %>%
  mutate(ethnic_identity_middle_east = case_when(ethnic_identity_middle_east == "missing" ~ "Missing",
                                     ethnic_identity_middle_east == "israeli" ~ "Israeli",
                                     ethnic_identity_middle_east == "african" ~ "African (Ethiopian)",
                                     ethnic_identity_middle_east == "mid_eastern" ~ "Middle Eastern or Mediterranean",
                                     ethnic_identity_middle_east == "european_n_am" ~ "European or North American",
                                     ethnic_identity_middle_east == "s_central_am" ~ "South or Central American",
                                     ethnic_identity_middle_east == "ussr_e_european" ~ "Former Soviet Union or Eastern European",
                                     ethnic_identity_middle_east == "ne_asian" ~ "Northeast Asian",
                                     ethnic_identity_middle_east == "other" ~ "Another ethnicity not listed",
                                     TRUE ~ ethnic_identity_middle_east))

```

```{r printing ethnicity tally, include=TRUE}

rempsyc::nice_table(ethnicity_tallies)

```

```{r setting up age for demographics table to word, include=FALSE}

## Here I start setting up demographic variables to 
## create a combined flextable that can be exported
## to a word document

# Specified character string for the new row
new_row <- tibble(
  `age` = "Age",
  `n` = NA_integer_,
  `%` = NA_real_
)

# Insert new row at position #1
age_tallies_for_table <- bind_rows(new_row, age_tallies) %>%
  rename(Demographics = age)

# View updated data frame
age_tallies_for_table

```

```{r setting up gender for demographics table to word, include=FALSE}

# Specified character string for the new row
new_row <- tibble(
  `gender_identity` = "Gender Identity",
  `n` = NA_integer_,
  `%` = NA_real_
)

# Insert new row at position #1
gender_tallies_for_table <- bind_rows(new_row, gender_tallies) %>%
  rename(Demographics = gender_identity)

# View updated data frame
gender_tallies_for_table

```

```{r setting up sexual orientation for demographics table to word, include=FALSE}

# Specified character string for the new row
new_row <- tibble(
  `sex_orientation` = "Sexual Orientation",
  `n` = NA_integer_,
  `%` = NA_real_
)

# Insert new row at position #1
sex_orientation_tallies_for_table <- bind_rows(new_row, sex_orientation_tallies) %>%
  rename(Demographics = sex_orientation)

# View updated data frame
sex_orientation_tallies_for_table

```

```{r setting up race for demographics table to word, include=FALSE}

# Specified character string for the new row
new_row <- tibble(
  `racial_ethnic_identity` = "Racial/Ethnic Identity",
  `n` = NA_integer_,
  `%` = NA_real_
)

# Insert new row at position #1
race_tallies_for_table <- bind_rows(new_row, race_tallies) %>%
  rename(Demographics = racial_ethnic_identity)

# View updated data frame
race_tallies_for_table

```

```{r setting up ethnicity for demographics table to word, include=FALSE}

# Specified character string for the new row
new_row <- tibble(
  `ethnic_identity_middle_east` = "Ethnic Identity Middle East",
  `n` = NA_integer_,
  `%` = NA_real_
)

# Insert new row at position #1
ethnicity_tallies_for_table <- bind_rows(new_row, ethnicity_tallies) %>%
  rename(Demographics = ethnic_identity_middle_east)

# View updated data frame
ethnicity_tallies_for_table

```

```{r creating combined df for demographics table, include=FALSE}

demographics_tallies <- bind_rows(age_tallies_for_table,
                          gender_tallies_for_table,
                          sex_orientation_tallies_for_table,
                          race_tallies_for_table,
                          ethnicity_tallies_for_table)

```

```{r creating demo flextable, include=FALSE}

# Create a flextable directly from tallies
flextable_output <- flextable::flextable(demographics_tallies)

```

```{r formatting demo flextable, include=FALSE}

# Applying indents within demographic variable categories

flextable_age_formatted <- padding(flextable_output, i=2:8, padding.left = 20)

flextable_gender_formatted <- padding(flextable_age_formatted, i=10:27, padding.left = 20)

flextable_sex_orientation_formatted <- padding(flextable_gender_formatted, i=29:41, padding.left = 20)

flextable_race_formatted <- padding(flextable_sex_orientation_formatted, i=43:48, padding.left = 20)

flextable_ethnicity_formatted <- padding(flextable_race_formatted, i=50:58, padding.left = 20)

# Autofitting columns

flextable_all_demographics <- flextable::autofit(flextable_ethnicity_formatted)

```

```{r exporting demo flextable to word, include=FALSE}

# Create a Word document
doc <- officer::read_docx()

# Add the flextable to the document
doc <- flextable::body_add_flextable(doc, value = flextable_all_demographics)

# Specify root directory
tables_folder <- here("tables")

# Create "tables" folder if it doesn't exist
if (!dir.exists(tables_folder)) {
  dir.create(tables_folder)
}
  
# Save the document to the "tables" folder in your project root
print(doc, target = file.path(tables_folder, "demographics_table.docx"))

```

# Clinical Outcomes 

```{r plot setup, include=FALSE, warning=FALSE}

## Loading required packages

library(tidyverse)
library(ggridges)
library(showtext)

## Setting up fonts

font_add_google(name = "Noto Sans",
                family = "noto sans")

showtext::showtext_auto()

```

## ABC Project

```{r, out.width = "260px", out.height = "250px", include=TRUE, echo=FALSE}

knitr::include_graphics("/Users/mallorydobias/Documents/R/yes_project/images/yes_abc_graphic.png")

```

Conducting a paired t-test to evaluate pre vs post-abc changes in hopelessness (bhs scores). For those who chose the abc intervention with data at both time points, hopelessness decreased from pre to post abc, dz = `r abc_bhs_dz_value`.

```{r t test results abc bhs}

t_abc_bhs

```

```{r t test effect size abc bhs}

abc_bhs_dz_value

```

```{r visualizing pre-post bhs abc setup, include=FALSE}

## Selecting pre and post vars for abc

pre_post_bhs_abc <- data_youth %>% 
  filter(str_detect(ssi_started, "A.B.C.")) %>%
  dplyr::select(pre_bhs_mean, post_bhs_mean)

# Converting to long data format

pre_post_bhs_abc_long <- pivot_longer(pre_post_bhs_abc, 
                                           cols = contains("mean"), 
                                           names_to = "timing", 
                                           values_to = "hopelessness")

##  Renaming for plot

plot_data_bhs_abc <- pre_post_bhs_abc_long %>% 
  mutate(timing = case_when(str_detect(timing, "pre") ~ "Before",
         str_detect(timing, "post") ~ "After",
         is.na(timing) ~ NA_character_))

```

```{r writing plot function for future plots, include=FALSE}

## Writing a function for future plot setup

process_plot_data <- function(data, ssi_string, pre_var, post_var, outcome_label) {
  # Select pre and post variables based on the ssi string
  pre_post_outcome <- data_youth %>%
    filter(str_detect(ssi_started, ssi_string)) %>%
    dplyr::select(contains(pre_var), 
                  contains(post_var))
  
  # Convert to long data format
  pre_post_outcome_long <- pre_post_outcome %>%
    pivot_longer(cols = contains("mean"), 
                 names_to = "timing", 
                 values_to = outcome_label)
  
  # Mutate 'timing' to label pre/post as 'Before'/'After'
  plot_data <- pre_post_outcome_long %>%
    mutate(timing = case_when(
      str_detect(timing, "pre") ~ "Before",
      str_detect(timing, "post") ~ "After",
      is.na(timing) ~ NA_character_
    ))
  
  return(plot_data)
}

```

```{r running custom plot function on abc bhs data, include=FALSE}

## Running plot setup function

plot_data_bhs_abc_function <- process_plot_data(data_youth, "A.B.C.", "pre_bhs_mean", "post_bhs_mean", "hopelessness")

```

```{r checking data frames are identical with and without function, include=FALSE}

identical(plot_data_bhs_abc, plot_data_bhs_abc_function) # true if processed data is identical using function

```

```{r visualizing pre-post bhs abc, include=FALSE, warning=FALSE}

## Plotting

plot_abc_bhs <- plot_data_bhs_abc_function %>%
  ggplot(aes(x = hopelessness, y = timing, fill = timing, color = timing)) +
  geom_density_ridges(alpha = 0.4,
                      jittered_points = TRUE,
                      position = "raincloud") +
  scale_fill_manual(values = c("#32A2A0", "grey")) +
  scale_color_manual(values = c("#32A2A0", "grey")) +
  scale_x_continuous(limits = c(0, 3)) +  # Set x-axis limits
  theme_light() +
  theme(legend.position = "none",
        text = element_text(family = "noto sans"),
        title = element_text(size = 10),
        plot.background = element_rect(fill = "white")) +
  labs(x = "Hopelessness", y = " ")

```

Plotting hopelessness pre and post abc

```{r plotting bhs pre and post abc, warning=FALSE, message=FALSE}

plot_abc_bhs

```

Conducting a paired t-test to evaluate pre vs post-abc changes in agency (shs pathways scores). For those who chose the abc intervention with data at both time points, agency increased from pre to post abc, dz = `r abc_shs_dz_value`.

```{r t test results abc shs}

t_abc_shs

```

```{r t test effect size abc shs}

abc_shs_dz_value

```

```{r running custom plot function on abc shs data, include=FALSE}

## Running plot setup function

plot_data_shs_abc_function <- process_plot_data(data_youth, "A.B.C.", "pre_shs_mean", "post_shs_mean", "hope")

```

```{r visualizing pre-post shs abc, include=FALSE, warning=FALSE}

## Plotting

plot_abc_shs <- plot_data_shs_abc_function %>%
  ggplot(aes(x = hope, y = timing, fill = timing, color = timing)) +
  geom_density_ridges(alpha = 0.4,
                      jittered_points = TRUE,
                      position = "raincloud") +
  scale_fill_manual(values = c("#32A2A0", "grey")) +
  scale_color_manual(values = c("#32A2A0", "grey")) +
  scale_x_continuous(limits = c(1, 8)) +  # Set x-axis limits
  theme_light() +
  theme(legend.position = "none",
        text = element_text(family = "noto sans"),
        title = element_text(size = 10),
        plot.background = element_rect(fill = "white")) +
  labs(x = "Agency", y = " ")

```

Plotting agency pre and post abc

```{r plotting shs pre and post abc, warning=FALSE, message=FALSE}

plot_abc_shs

```

Conducting a paired t-test to evaluate pre vs post-abc changes in self-hate (self-hate scale scores). For those who chose the abc intervention with data at both time points, self-hate decreased from pre to post abc, dz = `r abc_hate_dz_value`.

```{r t test results abc hate}

t_abc_hate

```

```{r t test effect size abc hate}

abc_hate_dz_value

```

```{r running custom plot function on abc hate data, include=FALSE}

## Running plot setup function

plot_data_hate_abc_function <- process_plot_data(data_youth, "A.B.C.", "pre_self_hate_mean", "post_self_hate_mean", "hate")

```

```{r visualizing pre-post hate abc, include=FALSE, warning=FALSE}

## Plotting

plot_abc_hate <- plot_data_hate_abc_function %>%
  ggplot(aes(x = hate, y = timing, fill = timing, color = timing)) +
  geom_density_ridges(alpha = 0.4,
                      jittered_points = TRUE,
                      position = "raincloud") +
  scale_fill_manual(values = c("#32A2A0", "grey")) +
  scale_color_manual(values = c("#32A2A0", "grey")) +
  scale_x_continuous(limits = c(1, 7)) +  # Set x-axis limits
  theme_light() +
  theme(legend.position = "none",
        text = element_text(family = "noto sans"),
        title = element_text(size = 10),
        plot.background = element_rect(fill = "white")) +
  labs(x = "Self-Hate", y = " ")

```

Plotting self-hate pre and post abc

```{r plotting hate pre and post abc, warning=FALSE, message=FALSE}

plot_abc_hate

```

Combining all abc pre-post outcomes into one plot. Left plot shows distributions of hopelessness scores (BHS scale) before and after abc; middle plot shows distributions of pathway scores (SHS scale, pathways subscale) before and after abc; right plot shows distributions of self-hate scores before and after abc. Within each plot, higher scores (i.e., further to the right) reflect more hopelessness, hope, and self-hate respectively.

```{r combining abc pre post outcomes plots, echo=FALSE, warning=FALSE, message=FALSE}

## Plotting all pre post outcomes for abc

plots_abc <- plot_abc_bhs + plot_abc_shs + plot_abc_hate +
  plot_annotation(title = "Outcomes before vs after ABC Project",
                  theme = theme(plot.title = element_text(hjust = 0.5)))

plots_abc

```

## Project CARE

```{r, out.width = "260px", out.height = "250px", include=TRUE, echo=FALSE}

knitr::include_graphics("/Users/mallorydobias/Documents/R/yes_project/images/yes_care_graphic.png")

```

Conducting a paired t-test to evaluate pre vs post-care changes in hopelessness (bhs scores). For those who chose the care intervention with data at both time points, hopelessness decreased from pre to post care, dz = `r care_bhs_dz_value`.

```{r t test results care bhs}

t_care_bhs

```

```{r t test effect size care bhs}

care_bhs_dz_value

```

```{r running custom plot function on care bhs data, include=FALSE}

## Running plot setup function

plot_data_bhs_care_function <- process_plot_data(data_youth, "C.A.R.E", "pre_bhs_mean", "post_bhs_mean", "hopelessness")

```

```{r visualizing pre-post bhs care, include=FALSE, warning=FALSE}

## Plotting

plot_care_bhs <- plot_data_bhs_care_function %>%
  ggplot(aes(x = hopelessness, y = timing, fill = timing, color = timing)) +
  geom_density_ridges(alpha = 0.4,
                      jittered_points = TRUE,
                      position = "raincloud") +
  scale_fill_manual(values = c("#A52B4D", "grey")) +
  scale_color_manual(values = c("#A52B4D", "grey")) +
  scale_x_continuous(limits = c(0, 3)) +  # Set x-axis limits
  theme_light() +
  theme(legend.position = "none",
        text = element_text(family = "noto sans"),
        title = element_text(size = 10),
        plot.background = element_rect(fill = "white")) +
  labs(x = "Hopelessness", y = " ")

```

Plotting hopelessness pre and post care

```{r plotting bhs pre and post care, warning=FALSE, message=FALSE}

plot_care_bhs

```

Conducting a paired t-test to evaluate pre vs post-care changes in agency (shs pathways scores). For those who chose the care intervention with data at both time points, agency increased from pre to post care, dz = `r care_shs_dz_value`.

```{r t test results care shs}

t_care_shs

```

```{r t test effect size care shs}

care_shs_dz_value

```

```{r running custom plot function on care shs data, include=FALSE}

## Running plot setup function

plot_data_shs_care_function <- process_plot_data(data_youth, "C.A.R.E", "pre_shs_mean", "post_shs_mean", "hope")

```

```{r visualizing pre-post shs care, include=FALSE, warning=FALSE}

## Plotting

plot_care_shs <- plot_data_shs_care_function %>%
  ggplot(aes(x = hope, y = timing, fill = timing, color = timing)) +
  geom_density_ridges(alpha = 0.4,
                      jittered_points = TRUE,
                      position = "raincloud") +
  scale_fill_manual(values = c("#A52B4D", "grey")) +
  scale_color_manual(values = c("#A52B4D", "grey")) +
  scale_x_continuous(limits = c(1, 8)) +  # Set x-axis limits
  theme_light() +
  theme(legend.position = "none",
        text = element_text(family = "noto sans"),
        title = element_text(size = 10),
        plot.background = element_rect(fill = "white")) +
  labs(x = "Agency", y = " ")

```

Plotting agency pre and post care

```{r plotting shs pre and post care, warning=FALSE, message=FALSE}

plot_care_shs

```

Conducting a paired t-test to evaluate pre vs post-care changes in self-hate (self-hate scale scores). For those who chose the care intervention with data at both time points, self-hate decreased from pre to post care, dz = `r abc_hate_dz_value`.

```{r t test results care hate}

t_care_hate

```

```{r t test effect size care hate}

care_hate_dz_value

```

```{r running custom plot function on care hate data, include=FALSE}

## Running plot setup function

plot_data_hate_care_function <- process_plot_data(data_youth, "C.A.R.E", "pre_self_hate_mean", "post_self_hate_mean", "hate")

```

```{r visualizing pre-post hate care, include=FALSE, warning=FALSE}

## Plotting

plot_care_hate <- plot_data_hate_care_function %>%
  ggplot(aes(x = hate, y = timing, fill = timing, color = timing)) +
  geom_density_ridges(alpha = 0.4,
                      jittered_points = TRUE,
                      position = "raincloud") +
  scale_fill_manual(values = c("#A52B4D", "grey")) +
  scale_color_manual(values = c("#A52B4D", "grey")) +
  scale_x_continuous(limits = c(1, 7)) +  # Set x-axis limits
  theme_light() +
  theme(legend.position = "none",
        text = element_text(family = "noto sans"),
        title = element_text(size = 10),
        plot.background = element_rect(fill = "white")) +
  labs(x = "Self-Hate", y = " ")

```

Plotting self-hate pre and post care

```{r plotting hate pre and post care, warning=FALSE, message=FALSE}

plot_care_hate

```

Combining all project care pre-post outcomes into one plot. Left plot shows distributions of hopelessness scores (BHS scale) before and after project care; middle plot shows distributions of pathway scores (SHS scale, pathways subscale) before and after project care; right plot shows distributions of self-hate scores before and after project care. Within each plot, higher scores (i.e., further to the right) reflect more hopelessness, hope, and self-hate respectively.

```{r combining care pre post outcomes plots, echo=FALSE, warning=FALSE, message=FALSE}

## Plotting all pre post outcomes for care

plots_care <- plot_care_bhs + plot_care_shs + plot_care_hate +
  plot_annotation(title = "Outcomes before vs after Project CARE",
                  theme = theme(plot.title = element_text(hjust = 0.5)))

plots_care

```

## Project Personality

```{r, out.width = "260px", out.height = "240px", include=TRUE, echo=FALSE}

knitr::include_graphics("/Users/mallorydobias/Documents/R/yes_project/images/yes_pp_graphic.png")

```

Conducting a paired t-test to evaluate pre vs post-project personality changes in hopelessness (bhs scores). For those who chose the project personality intervention with data at both time points, hopelessness decreased from pre to post project personality, dz = `r pp_bhs_dz_value`.

```{r t test results pp bhs}

t_pp_bhs

```

```{r t test effect size pp bhs}

pp_bhs_dz_value

```

```{r running custom plot function on pp bhs data, include=FALSE}

## Running plot setup function

plot_data_bhs_pp_function <- process_plot_data(data_youth, "Personality", "pre_bhs_mean", "post_bhs_mean", "hopelessness")

```

```{r visualizing pre-post bhs pp, include=FALSE, warning=FALSE}

## Plotting

plot_pp_bhs <- plot_data_bhs_pp_function %>%
  ggplot(aes(x = hopelessness, y = timing, fill = timing, color = timing)) +
  geom_density_ridges(alpha = 0.4,
                      jittered_points = TRUE,
                      position = "raincloud") +
  scale_fill_manual(values = c("#3F9CF5", "grey")) +
  scale_color_manual(values = c("#3F9CF5", "grey")) +
  scale_x_continuous(limits = c(0, 3)) +  # Set x-axis limits
  theme_light() +
  theme(legend.position = "none",
        text = element_text(family = "noto sans"),
        title = element_text(size = 10),
        plot.background = element_rect(fill = "white")) +
  labs(x = "Hopelessness", y = " ")

```

Plotting hopelessness pre and post project personality

```{r plotting bhs pre and post pp, warning=FALSE, message=FALSE}

plot_pp_bhs

```

Conducting a paired t-test to evaluate pre vs post-project personality changes in agency (shs pathways scores). For those who chose the project personality intervention with data at both time points, agency increased from pre to post project personality, dz = `r pp_shs_dz_value`.

```{r t test results pp shs}

t_pp_shs

```

```{r t test effect size pp shs}

pp_shs_dz_value

```

```{r running custom plot function on pp shs data, include=FALSE}

## Running plot setup function

plot_data_shs_pp_function <- process_plot_data(data_youth, "Personality", "pre_shs_mean", "post_shs_mean", "hope")

```

```{r visualizing pre-post shs pp, include=FALSE, warning=FALSE}

## Plotting

plot_pp_shs <- plot_data_shs_pp_function %>%
  ggplot(aes(x = hope, y = timing, fill = timing, color = timing)) +
  geom_density_ridges(alpha = 0.4,
                      jittered_points = TRUE,
                      position = "raincloud") +
  scale_fill_manual(values = c("#3F9CF5", "grey")) +
  scale_color_manual(values = c("#3F9CF5", "grey")) +
  scale_x_continuous(limits = c(1, 8)) +  # Set x-axis limits
  theme_light() +
  theme(legend.position = "none",
        text = element_text(family = "noto sans"),
        title = element_text(size = 10),
        plot.background = element_rect(fill = "white")) +
  labs(x = "Agency", y = " ")

```

Plotting agency pre and post project personality

```{r plotting shs pre and post pp, warning=FALSE, message=FALSE}

plot_pp_shs

```

Conducting a paired t-test to evaluate pre vs post-project personality changes in self-hate (self-hate scale scores). For those who chose the project personality intervention with data at both time points, self-hate decreased from pre to post project personality, dz = `r pp_hate_dz_value`.

```{r t test results pp hate}

t_pp_hate

```

```{r t test effect size pp hate}

pp_hate_dz_value

```

```{r running custom plot function on pp hate data, include=FALSE}

## Running plot setup function

plot_data_hate_pp_function <- process_plot_data(data_youth, "Personality", "pre_self_hate_mean", "post_self_hate_mean", "hate")

```

```{r visualizing pre-post hate pp, include=FALSE, warning=FALSE}

## Plotting

plot_pp_hate <- plot_data_hate_pp_function %>%
  ggplot(aes(x = hate, y = timing, fill = timing, color = timing)) +
  geom_density_ridges(alpha = 0.4,
                      jittered_points = TRUE,
                      position = "raincloud") +
  scale_fill_manual(values = c("#3F9CF5", "grey")) +
  scale_color_manual(values = c("#3F9CF5", "grey")) +
  scale_x_continuous(limits = c(1, 7)) +  # Set x-axis limits
  theme_light() +
  theme(legend.position = "none",
        text = element_text(family = "noto sans"),
        title = element_text(size = 10),
        plot.background = element_rect(fill = "white")) +
  labs(x = "Self-Hate", y = " ")

```

Plotting self-hate pre and post project personality

```{r plotting hate pre and post pp, warning=FALSE, message=FALSE}

plot_pp_hate

```

Combining all project personality pre-post outcomes into one plot. Left plot shows distributions of hopelessness scores (BHS scale) before and after project personality; middle plot shows distributions of pathway scores (SHS scale, pathways subscale) before and after project personality; right plot shows distributions of self-hate scores before and after project personality Within each plot, higher scores (i.e., further to the right) reflect more hopelessness, hope, and self-hate respectively.

```{r combining pp pre post outcomes plots, echo=FALSE, warning=FALSE, message=FALSE}

## Plotting all pre post outcomes for pp

plots_pp <- plot_pp_bhs + plot_pp_shs + plot_pp_hate +
  plot_annotation(title = "Outcomes before vs after Project Personality",
                  theme = theme(plot.title = element_text(hjust = 0.5)))

plots_pp

```

## Project RISE

```{r, out.width = "260px", out.height = "240px", include=TRUE, echo=FALSE}

knitr::include_graphics("/Users/mallorydobias/Documents/R/yes_project/images/yes_rise_graphic.png")

```

Conducting a paired t-test to evaluate pre vs post-rise changes in hopelessness (bhs scores). For those who chose the rise intervention with data at both time points, we find no evidence that hopelessness decreased from pre to post rise, dz = `r rise_bhs_dz_value`. However, this test is currently run in a very small sample size (df = `r d.dep.t.diff.t(rise_hate_t_value, rise_hate_n_pairs, a = 0.05)$df`).

```{r t test results rise bhs}

t_rise_bhs

```

```{r t test effect size rise bhs}

rise_bhs_dz_value

```

```{r running custom plot function on rise bhs data, include=FALSE}

## Running plot setup function

plot_data_bhs_rise_function <- process_plot_data(data_youth, "RISE", "pre_bhs_mean", "post_bhs_mean", "hopelessness")

```

```{r visualizing pre-post bhs rise, include=FALSE, warning=FALSE}

## Plotting

plot_rise_bhs <- plot_data_bhs_rise_function %>%
  ggplot(aes(x = hopelessness, y = timing, fill = timing, color = timing)) +
  geom_density_ridges(alpha = 0.4,
                      jittered_points = TRUE,
                      position = "raincloud") +
  scale_fill_manual(values = c("#F48151", "grey")) +
  scale_color_manual(values = c("#F48151", "grey")) +
  scale_x_continuous(limits = c(0, 3)) +  # Set x-axis limits
  theme_light() +
  theme(legend.position = "none",
        text = element_text(family = "noto sans"),
        title = element_text(size = 10),
        plot.background = element_rect(fill = "white")) +
  labs(x = "Hopelessness", y = " ")

```

Plotting hopelessness pre and post project rise

```{r plotting bhs pre and post rise, warning=FALSE, message=FALSE}

plot_rise_bhs

```

Conducting a paired t-test to evaluate pre vs post-rise changes in agency (shs pathways scores). For those who chose the rise intervention with data at both time points, we find no evidence that agency increased from pre to post rise, dz = `r rise_shs_dz_value`. However, this test is currently run in a very small sample size (df = `r d.dep.t.diff.t(rise_hate_t_value, rise_hate_n_pairs, a = 0.05)$df`).

```{r t test results rise shs}

t_rise_shs

```

```{r t test effect size rise shs}

rise_shs_dz_value

```

```{r running custom plot function on rise shs data, include=FALSE}

## Running plot setup function

plot_data_shs_rise_function <- process_plot_data(data_youth, "RISE", "pre_shs_mean", "post_shs_mean", "hope")

```

```{r visualizing pre-post shs rise, include=FALSE, warning=FALSE}

## Plotting

plot_rise_shs <- plot_data_shs_rise_function %>%
  ggplot(aes(x = hope, y = timing, fill = timing, color = timing)) +
  geom_density_ridges(alpha = 0.4,
                      jittered_points = TRUE,
                      position = "raincloud") +
  scale_fill_manual(values = c("#F48151", "grey")) +
  scale_color_manual(values = c("#F48151", "grey")) +
  scale_x_continuous(limits = c(1, 8)) +  # Set x-axis limits
  theme_light() +
  theme(legend.position = "none",
        text = element_text(family = "noto sans"),
        title = element_text(size = 10),
        plot.background = element_rect(fill = "white")) +
  labs(x = "Agency", y = " ")

```

Plotting agency pre and post project rise

```{r plotting shs pre and post rise, warning=FALSE, message=FALSE}

plot_rise_shs

```

Conducting a paired t-test to evaluate pre vs post-rise changes in self-hate (self-hate scale scores). For those who chose the rise intervention with data at both time points, we find no evidence that self-hate decreased from pre to post rise, dz = `r rise_hate_dz_value`. However, this test is currently run in a very small sample size (df = `r d.dep.t.diff.t(rise_hate_t_value, rise_hate_n_pairs, a = 0.05)$df`). 

```{r t test results rise hate}

t_rise_hate

```

```{r t test effect size rise hate}

rise_hate_dz_value

```

```{r running custom plot function on rise hate data, include=FALSE}

## Running plot setup function

plot_data_hate_rise_function <- process_plot_data(data_youth, "RISE", "pre_self_hate_mean", "post_self_hate_mean", "hate")

```

```{r visualizing pre-post hate rise, include=FALSE, warning=FALSE}

## Plotting

plot_rise_hate <- plot_data_hate_rise_function %>%
  ggplot(aes(x = hate, y = timing, fill = timing, color = timing)) +
  geom_density_ridges(alpha = 0.4,
                      jittered_points = TRUE,
                      position = "raincloud") +
  scale_fill_manual(values = c("#F48151", "grey")) +
  scale_color_manual(values = c("#F48151", "grey")) +
  scale_x_continuous(limits = c(1, 7)) +  # Set x-axis limits
  theme_light() +
  theme(legend.position = "none",
        text = element_text(family = "noto sans"),
        title = element_text(size = 10),
        plot.background = element_rect(fill = "white")) +
  labs(x = "Self-Hate", y = " ")

```

Plotting self-hate pre and post project rise

```{r plotting hate pre and post rise, warning=FALSE, message=FALSE}

plot_rise_hate

```

Combining all project rise pre-post outcomes into one plot. Left plot shows distributions of hopelessness scores (BHS scale) before and after project rise; middle plot shows distributions of pathway scores (SHS scale, pathways subscale) before and after project rise; right plot shows distributions of self-hate scores before and after project rise Within each plot, higher scores (i.e., further to the right) reflect more hopelessness, hope, and self-hate respectively.

```{r combining rise pre post outcomes plots, echo=FALSE, warning=FALSE, message=FALSE}

## Plotting all pre post outcomes for rise

plots_rise <- plot_rise_bhs + plot_rise_shs + plot_rise_hate +
  plot_annotation(title = "Outcomes before vs after Project RISE",
                  theme = theme(plot.title = element_text(hjust = 0.5)))

plots_rise

```

## All

```{r combining all pre post outcomes plots, echo=FALSE, warning=FALSE, message=FALSE}

library(patchwork)

# Combine the plots vertically
plots_all <- plots_abc / plots_care / plots_pp / plots_rise  + 
  plot_annotation(
    title = "Outcomes before and after all SSIs",
    caption = "hopelessness, hope, self-hate before + after ABC (green), CARE (red), Project Personality (blue), and RISE (orange)"
  )

# Show the combined plot
plots_all

```

# SSI Completion

## ABC Project

Of `r n_started_abc` cases where someone started abc, `r n_completed_abc` cases completed the intervention. This results in an abc completion rate of `r perc_completed_abc`%.

```{r n started abc}

n_started_abc

```

```{r n completed abc}

n_completed_abc

```

```{r perc completed abc}

perc_completed_abc

```

## Project CARE

Of `r n_started_care` cases where someone started care, `r n_completed_care` cases completed the intervention. This results in an project care completion rate of `r perc_completed_care`%.

```{r n started care}

n_started_care

```

```{r n completed care}

n_completed_care

```

```{r perc completed care}

perc_completed_care

```

## Project Personality

Of `r n_started_pp` cases where someone started project personality, `r n_completed_pp` cases completed the intervention. This results in a project personality completion rate of `r perc_completed_personality`%.

```{r n started pp}

n_started_pp

```

```{r n completed pp}

n_completed_pp

```

```{r perc completed pp}

perc_completed_personality

```

## Project RISE

Of `r n_started_rise` cases where someone started project rise, `r n_completed_rise` cases completed the intervention. This results in a project rise completion rate of `r perc_completed_rise`%.

```{r n started rise}

n_started_rise

```

```{r n completed rise}

n_completed_rise

```

```{r perc completed rise}

perc_completed_rise

```

## By SSI

Here, we plot starters vs completers by each SSI.

```{r setting up data for bar plot completion rates, include=FALSE}

# Create data for bar plot

data_barplot_abc <- data.frame(
  ssi = c("ABC Project"),
  category = c("starters", "completers"),
  n = c(as.integer(n_started_abc), as.integer(n_completed_abc))
)

data_barplot_care <- data.frame(
  ssi = c("Project CARE"),
  category = c("starters", "completers"),
  n = c(as.integer(n_started_care), as.integer(n_completed_care))
)

data_barplot_pp <- data.frame(
  ssi = c("Project Personality"),
  category = c("starters", "completers"),
  n = c(as.integer(n_started_pp), as.integer(n_completed_pp))
)

data_barplot_rise <- data.frame(
  ssi = c("Project RISE"),
  category = c("starters", "completers"),
  n = c(as.integer(n_started_rise), as.integer(n_completed_rise))
)

data_barplot_all <- bind_rows(data_barplot_abc, data_barplot_care,
                              data_barplot_pp, data_barplot_rise)

```

```{r writing plot settings for bar plot completion rates, include=FALSE}

# Define colors for each ssi and category combination

custom_colors <- c(
  "ABC Project.starters" = "#a4e3e2", "ABC Project.completers" = "#32A2A0",
  "Project CARE.starters" = "#e69fb3", "Project CARE.completers" = "#A52B4D",
  "Project Personality.starters" = "#b2d7fb", "Project Personality.completers" = "#3F9CF5",
  "Project RISE.starters" = "#fbcdb9", "Project RISE.completers" = "#F48151"
)

# Reorder 'ssi' factor
data_barplot_all$ssi <- factor(data_barplot_all$ssi, 
                               levels = c("ABC Project", "Project CARE", "Project Personality", "Project RISE"))

# Reorder 'category' factor to ensure "starters" comes before "completers" within each 'ssi'
data_barplot_all$category <- fct_relevel(data_barplot_all$category, "starters", "completers")

# Reorder 'interaction(ssi, category)' factor to match the desired order
data_barplot_all$interaction_ssi_category <- interaction(data_barplot_all$ssi, data_barplot_all$category)

# Ensure the interaction factor levels are in the right order for both bars and the legend
data_barplot_all$interaction_ssi_category <- factor(data_barplot_all$interaction_ssi_category, 
                                                    levels = c("ABC Project.starters", "ABC Project.completers",
                                                               "Project CARE.starters", "Project CARE.completers",
                                                               "Project Personality.starters", "Project Personality.completers",
                                                               "Project RISE.starters", "Project RISE.completers"))

```

```{r plotting completion rates, echo=FALSE, warning=FALSE, message=FALSE}

# Bar plot

ggplot(data_barplot_all, aes(x = ssi, y = n, fill = interaction_ssi_category)) +   
  geom_bar(position = "identity", stat = "identity") +
  scale_fill_manual(values = custom_colors) +
  coord_flip() +  # Flip coordinates to get horizontal bars
  scale_x_discrete(limits = rev(levels(data_barplot_all$ssi))) +  # Reverse x-axis to fix order after flip
  theme_minimal() +
  labs(x = "", y = "n completed vs n started (%)", title = "Completion Rates, by SSI") +
  theme(legend.position = "none") + 
  scale_y_continuous(limits = c(0, 2250)) +  # Set y-axis max to 200
  annotate(geom = "text", 
           x = 4,  # Adjust x to match where you want the text (based on your data)
           y = 300,  # Adjust y position as needed
           label = paste(perc_completed_abc, "%"), 
           color = "black", 
           size = 4) + # Customize size and color of the annotation
  annotate(geom = "text", 
           x = 3,  # Adjust x to match where you want the text (based on your data)
           y = 290,  # Adjust y position as needed
           label = paste(perc_completed_care, "%"), 
           color = "black", 
           size = 4) + # Customize size and color of the annotation
  annotate(geom = "text", 
           x = 2,  # Adjust x to match where you want the text (based on your data)
           y = 430,  # Adjust y position as needed
           label = paste(perc_completed_personality, "%"), 
           color = "black", 
           size = 4) +
  annotate(geom = "text", 
           x = 1,  # Adjust x to match where you want the text (based on your data)
           y = 290,  # Adjust y position as needed
           label = paste(perc_completed_rise, "%"), 
           color = "black", 
           size = 4) +
  geom_segment(aes(y = 20, yend = 120, x = 1, xend = 1), 
               linetype = "solid", color = "black", size = .5)

```

## All

Of `r n_started_any_ssi` cases where someone started any ssi, `r n_completed_any_ssi` cases completed the intervention. This results in an overall completion rate of `r perc_completed_any_ssi`% for any ssi.

```{r n started any ssi}

n_started_any_ssi

```

```{r n completed any ssi}

n_completed_any_ssi

```

```{r perc completed any ssi}

perc_completed_any_ssi

```

# Acceptability

## Overall

```{r calculating pfs item means across all ssis, include=FALSE}

## Calculating individual pfs item means, across all ssis

summary_pfs_enjoyed <- data_youth %>%
  summarize(mean_value = round(mean(pfs_1, na.rm = TRUE), 2),
            sd_value = round(sd(pfs_1, na.rm = TRUE), 2)) %>%
  mutate(pfs_item = "enjoyed",
         mean_value = mean_value,
         sd_value = sd_value)

summary_pfs_understood <- data_youth %>%
  summarize(mean_value = round(mean(pfs_2, na.rm = TRUE), 2),
            sd_value = round(sd(pfs_2, na.rm = TRUE), 2)) %>%
  mutate(pfs_item = "understood",
         mean_value = mean_value,
         sd_value = sd_value)

summary_pfs_easy <- data_youth %>%
  summarize(mean_value = round(mean(pfs_3, na.rm = TRUE), 2),
            sd_value = round(sd(pfs_3, na.rm = TRUE), 2)) %>%
  mutate(pfs_item = "easy to use",
         mean_value = mean_value,
         sd_value = sd_value)

summary_pfs_tried <- data_youth %>%
  summarize(mean_value = round(mean(pfs_4, na.rm = TRUE), 2),
            sd_value = round(sd(pfs_4, na.rm = TRUE), 2)) %>%
  mutate(pfs_item = "tried my hardest",
         mean_value = mean_value,
         sd_value = sd_value)

summary_pfs_helpful <- data_youth %>%
  summarize(mean_value = round(mean(pfs_5, na.rm = TRUE), 2),
            sd_value = round(sd(pfs_5, na.rm = TRUE), 2)) %>%
  mutate(pfs_item = "helpful for others",
         mean_value = mean_value,
         sd_value = sd_value)

summary_pfs_recommend <- data_youth %>%
  summarize(mean_value = round(mean(pfs_6, na.rm = TRUE), 2),
            sd_value = round(sd(pfs_6, na.rm = TRUE), 2)) %>%
  mutate(pfs_item = "recommend to others",
         mean_value = mean_value,
         sd_value = sd_value)

summary_pfs_agree <- data_youth %>%
  summarize(mean_value = round(mean(pfs_7, na.rm = TRUE), 2),
            sd_value = round(sd(pfs_7, na.rm = TRUE), 2)) %>%
  mutate(pfs_item = "agree with message",
         mean_value = mean_value,
         sd_value = sd_value)

```

```{r pulling pfs item means across all ssis into one df, include=FALSE}

## Pulling into one data frame

summary_pfs_overall <- dplyr::bind_rows(
  summary_pfs_enjoyed, summary_pfs_understood, summary_pfs_easy,
  summary_pfs_tried, summary_pfs_helpful, summary_pfs_recommend,
  summary_pfs_agree) %>%
  select(pfs_item, mean = mean_value, sd = sd_value)

```

Overall PFS scale item descriptives across all SSIs

```{r printing overall pfs item descriptives across all ssis}

summary_pfs_overall

```

```{r creating custom function to calculate pfs item descriptives, include=FALSE}

## I'll use this function to calculate pfs item descriptives for each ssi

# Define the function
calculate_pfs_item_means <- function(data) {
  
  # Create a list of variable names and their corresponding item descriptions
  pfs_items <- list(
    pfs_1 = "enjoyed",
    pfs_2 = "understood",
    pfs_3 = "easy to use",
    pfs_4 = "tried my hardest",
    pfs_5 = "helpful for others",
    pfs_6 = "recommend to others",
    pfs_7 = "agree with message"
  )
  
  # Initialize an empty list to store the summaries
  summaries <- list()
  
  # Loop through each item and calculate the mean and sd
  for (pfs in names(pfs_items)) {
    summary <- data %>%
      summarize(mean_value = round(mean(.data[[pfs]], na.rm = TRUE), 2),
                sd_value = round(sd(.data[[pfs]], na.rm = TRUE), 2)) %>%
      mutate(pfs_item = pfs_items[[pfs]],
             mean_value = mean_value,
             sd_value = sd_value)
    
    summaries[[pfs]] <- summary
  }
  
  # Combine all summaries into a single data frame
  summary_pfs_overall <- bind_rows(summaries) %>%
    select(pfs_item, mean = mean_value, sd = sd_value)
  
  return(summary_pfs_overall)
}

```

```{r testing custom pfs function, include=FALSE}

# Testing with overall data_youth dataset
summary_pfs_overall_function <- calculate_pfs_item_means(data_youth)

# Print the overall PFS item descriptives
summary_pfs_overall_function

# Checking if this works
identical(summary_pfs_overall, summary_pfs_overall_function) # true if results are identical with and without function

```

```{r creating data for overall pfs ridge plot, include=FALSE}

# Creating data for overall pfs score ridge plot

data_overall_ridge_plot <- data_youth %>%
  select(ssi_choice, pfs_mean) %>%
  filter(!is.na(ssi_choice) & !is.na(pfs_mean))

```

```{r plotting overall pfs mean scores by ssi, include=FALSE, warning=FALSE}
 
# Setting a group order

custom_order <- c("ABC Project", "Project CARE", "Project Personality", "Project RISE")

# Convert ssi_choice to a factor with the specified order
data_overall_ridge_plot_mutated <- data_overall_ridge_plot %>%
  mutate(ssi_choice = factor(data_overall_ridge_plot$ssi_choice, levels = custom_order))

# Defining colors for each group

custom_colors <- c("ABC Project" = "#32A2A0", 
                   "Project CARE" = "#A52B4D", 
                   "Project Personality" = "#3F9CF5", 
                   "Project RISE" = "#F48151")

# Plotting pfs mean scores by ssi chosen

plot_overall_pfs_ridge <- ggplot(data_overall_ridge_plot, aes(x = pfs_mean, 
                                                              y = reorder(ssi_choice, -as.numeric(ssi_choice)), 
                                                              fill = ssi_choice, color = ssi_choice)) +  
  geom_density_ridges(alpha = 0.8) +
  theme_ridges() + 
  theme(legend.position = "none") +
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +
  labs(y = "", x = "PFS Mean Scores") +
  plot_annotation(title = "PFS Mean Scores by Chosen SSI",
                  caption = "Overall Program Feedback Scale mean scores by SSI, where higher scores reflect more positive feedback")

```

```{r printing plot overall pfs means by ssi, warning=FALSE, message=FALSE, include=TRUE}

plot_overall_pfs_ridge

```


## ABC Project

PFS scale item descriptives for abc

```{r pfs item desctiptives for abc}

## Running custom function to get pfs item descriptives 

summary_pfs_abc <- calculate_pfs_item_means(data_youth_abc)

## Print descriptives

summary_pfs_abc

```

```{r setting up data for pfs abc ridge plot, include=FALSE}

# Setting up data for ridge plot 

data_abc_ridge_plot <- data_youth_abc %>%
  select(starts_with("pfs_") & 
         -contains("like") & -contains("change"), 
         -contains("mean"), -contains("feedback"), 
         -contains("tim")) %>%
  pivot_longer(cols = everything()) %>%
  rename(pfs_item = name) %>%
  mutate(pfs_item = case_when(pfs_item == "pfs_1" ~ "enjoyed",
                              pfs_item == "pfs_2" ~ "understood",
                              pfs_item == "pfs_3" ~ "easy to use",
                              pfs_item == "pfs_4" ~ "tried my hardest",
                              pfs_item == "pfs_5" ~ "helpful for others",
                              pfs_item == "pfs_6" ~ "recommend to others",
                              pfs_item == "pfs_7" ~ "agree with message",
                              TRUE ~ pfs_item))

```

```{r plotting abc pfs items scores, include=FALSE, message=FALSE, warning=FALSE}
 
# Setting a group order

custom_order <- c("enjoyed", "understood", "easy to use", "tried my hardest",
                  "helpful for others", "recommend to others", "agree with message")

# Convert pfs_item to a factor with the specified order

data_abc_ridge_plot_mutated <- data_abc_ridge_plot %>%
  mutate(pfs_item = factor(data_abc_ridge_plot$pfs_item, levels = custom_order))

# Plotting pfs item scores

plot_abc_pfs_ridge <- ggplot(data_abc_ridge_plot_mutated, aes(x = value, 
                                                              y = reorder(pfs_item, -as.numeric(pfs_item)),
                                                              fill = pfs_item, color = pfs_item)) +  
  geom_density_ridges(alpha = 0.6) +
  theme_ridges() + 
  theme(legend.position = "none") +
  scale_fill_manual(values = rep("#32A2A0", length(custom_order))) +  # Custom fill color
  scale_color_manual(values = rep("#32A2A0", length(custom_order))) +  # Custom color
  labs(y = "", x = "") +
  scale_x_continuous(breaks = c(1, 2, 3, 4, 5))  # Set the x-axis tick positions

plot_abc_pfs_ridge

```

## Project CARE

PFS scale item descriptives for care

```{r pfs item desctiptives for care}

## Running custom function to get pfs item descriptives 

summary_pfs_care <- calculate_pfs_item_means(data_youth_care)

## Print descriptives

summary_pfs_care

```

```{r setting up data for pfs care ridge plot, include=FALSE}

# Setting up data for ridge plot 

data_care_ridge_plot <- data_youth_care %>%
  select(starts_with("pfs_") & 
         -contains("like") & -contains("change"), 
         -contains("mean"), -contains("feedback"), 
         -contains("tim")) %>%
  pivot_longer(cols = everything()) %>%
  rename(pfs_item = name) %>%
  mutate(pfs_item = case_when(pfs_item == "pfs_1" ~ "enjoyed",
                              pfs_item == "pfs_2" ~ "understood",
                              pfs_item == "pfs_3" ~ "easy to use",
                              pfs_item == "pfs_4" ~ "tried my hardest",
                              pfs_item == "pfs_5" ~ "helpful for others",
                              pfs_item == "pfs_6" ~ "recommend to others",
                              pfs_item == "pfs_7" ~ "agree with message",
                              TRUE ~ pfs_item))

```

```{r plotting care pfs items scores, include=FALSE, message=FALSE, warning=FALSE}
 
# Setting a group order

custom_order <- c("enjoyed", "understood", "easy to use", "tried my hardest",
                  "helpful for others", "recommend to others", "agree with message")

# Convert pfs_item to a factor with the specified order

data_care_ridge_plot_mutated <- data_care_ridge_plot %>%
  mutate(pfs_item = factor(data_care_ridge_plot$pfs_item, levels = custom_order))

# Plotting pfs item scores

plot_care_pfs_ridge <- ggplot(data_care_ridge_plot_mutated, aes(x = value, 
                                                              y = reorder(pfs_item, -as.numeric(pfs_item)),
                                                              fill = pfs_item, color = pfs_item)) +  
  geom_density_ridges(alpha = 0.6) +
  theme_ridges() + 
  theme(legend.position = "none") +
  scale_fill_manual(values = rep("#A52B4D", length(custom_order))) +  # Custom fill color
  scale_color_manual(values = rep("#A52B4D", length(custom_order))) +  # Custom color
  labs(y = "", x = "") +
  scale_x_continuous(breaks = c(1, 2, 3, 4, 5))  # Set the x-axis tick positions

plot_care_pfs_ridge

```

## Project Personality

PFS scale item descriptives for project personality

```{r pfs item desctiptives for pp}

## Running custom function to get pfs item descriptives 

summary_pfs_pp <- calculate_pfs_item_means(data_youth_pp)

## Print descriptives

summary_pfs_pp

```

```{r setting up data for pfs pp ridge plot, include=FALSE}

# Setting up data for ridge plot 

data_pp_ridge_plot <- data_youth_pp %>%
  select(starts_with("pfs_") & 
         -contains("like") & -contains("change"), 
         -contains("mean"), -contains("feedback"), 
         -contains("tim")) %>%
  pivot_longer(cols = everything()) %>%
  rename(pfs_item = name) %>%
  mutate(pfs_item = case_when(pfs_item == "pfs_1" ~ "enjoyed",
                              pfs_item == "pfs_2" ~ "understood",
                              pfs_item == "pfs_3" ~ "easy to use",
                              pfs_item == "pfs_4" ~ "tried my hardest",
                              pfs_item == "pfs_5" ~ "helpful for others",
                              pfs_item == "pfs_6" ~ "recommend to others",
                              pfs_item == "pfs_7" ~ "agree with message",
                              TRUE ~ pfs_item))

```

```{r plotting pp pfs items scores, include=FALSE, message=FALSE, warning=FALSE}
 
# Setting a group order

custom_order <- c("enjoyed", "understood", "easy to use", "tried my hardest",
                  "helpful for others", "recommend to others", "agree with message")

# Convert pfs_item to a factor with the specified order

data_pp_ridge_plot_mutated <- data_pp_ridge_plot %>%
  mutate(pfs_item = factor(data_pp_ridge_plot$pfs_item, levels = custom_order))

# Plotting pfs item scores

plot_pp_pfs_ridge <- ggplot(data_pp_ridge_plot_mutated, aes(x = value, 
                                                              y = reorder(pfs_item, -as.numeric(pfs_item)),
                                                              fill = pfs_item, color = pfs_item)) +  
  geom_density_ridges(alpha = 0.6) +
  theme_ridges() + 
  theme(legend.position = "none") +
  scale_fill_manual(values = rep("#3F9CF5", length(custom_order))) +  # Custom fill color
  scale_color_manual(values = rep("#3F9CF5", length(custom_order))) +  # Custom color
  labs(y = "", x = "") +
  scale_x_continuous(breaks = c(1, 2, 3, 4, 5))  # Set the x-axis tick positions

plot_pp_pfs_ridge

```

## Project RISE

PFS scale item descriptives for rise

```{r pfs item desctiptives for rise}

## Running custom function to get pfs item descriptives 

summary_pfs_rise <- calculate_pfs_item_means(data_youth_rise)

## Print descriptives

summary_pfs_rise

```

```{r setting up data for pfs rise ridge plot, include=FALSE}

# Setting up data for ridge plot 

data_rise_ridge_plot <- data_youth_rise %>%
  select(starts_with("pfs_") & 
         -contains("like") & -contains("change"), 
         -contains("mean"), -contains("feedback"), 
         -contains("tim")) %>%
  pivot_longer(cols = everything()) %>%
  rename(pfs_item = name) %>%
  mutate(pfs_item = case_when(pfs_item == "pfs_1" ~ "enjoyed",
                              pfs_item == "pfs_2" ~ "understood",
                              pfs_item == "pfs_3" ~ "easy to use",
                              pfs_item == "pfs_4" ~ "tried my hardest",
                              pfs_item == "pfs_5" ~ "helpful for others",
                              pfs_item == "pfs_6" ~ "recommend to others",
                              pfs_item == "pfs_7" ~ "agree with message",
                              TRUE ~ pfs_item))

```

```{r plotting rise pfs items scores, include=FALSE, message=FALSE, warning=FALSE}
 
# Setting a group order

custom_order <- c("enjoyed", "understood", "easy to use", "tried my hardest",
                  "helpful for others", "recommend to others", "agree with message")

# Convert pfs_item to a factor with the specified order

data_rise_ridge_plot_mutated <- data_rise_ridge_plot %>%
  mutate(pfs_item = factor(data_rise_ridge_plot$pfs_item, levels = custom_order))

# Plotting pfs item scores

plot_rise_pfs_ridge <- ggplot(data_rise_ridge_plot_mutated, aes(x = value, 
                                                              y = reorder(pfs_item, -as.numeric(pfs_item)),
                                                              fill = pfs_item, color = pfs_item)) +  
  geom_density_ridges(alpha = 0.6) +
  theme_ridges() + 
  theme(legend.position = "none") +
  scale_fill_manual(values = rep("#F48151", length(custom_order))) +  # Custom fill color
  scale_color_manual(values = rep("#F48151", length(custom_order))) +  # Custom color
  labs(y = "", x = "") +
  scale_x_continuous(breaks = c(1, 2, 3, 4, 5))  # Set the x-axis tick positions

plot_rise_pfs_ridge

```

## By SSI

```{r combining all ridge plots, warning=FALSE, message=FALSE, include=FALSE}

library(patchwork)

# Combine the plots vertically
plot_all_ridge <- plot_abc_pfs_ridge + plot_care_pfs_ridge + plot_pp_pfs_ridge + plot_rise_pfs_ridge +
  plot_annotation(
    title = "PFS Items Scores for Each SSI",
    caption = "ABC (green), CARE (red), Project Personality (blue), RISE (orange); higher scores reflect greater agreement"
  )

```

```{r printing ridge plot for all pfs, message=FALSE, warning=FALSE, include=TRUE}

plot_all_ridge

```

```{r setting up data for boxplots, include=FALSE}

data_abc_box_plot <- data_abc_ridge_plot %>%
  mutate(ssi_choice = "ABC Project")

data_care_box_plot <- data_care_ridge_plot %>%
  mutate(ssi_choice = "Project CARE")

data_pp_box_plot <- data_pp_ridge_plot %>%
  mutate(ssi_choice = "Project Personality")

data_rise_box_plot <- data_rise_ridge_plot %>%
  mutate(ssi_choice = "Project RISE")

data_pfs_boxplot <- bind_rows(data_abc_box_plot,
                              data_care_box_plot,
                              data_pp_box_plot,
                              data_rise_box_plot)

# Setting ssi order

custom_order_ssi <- c("ABC Project", "Project CARE", "Project Personality", "Project RISE")

# Setting pfs order

custom_order_pfs <- c("enjoyed", "understood", "easy to use", "tried my hardest",
                  "helpful for others", "recommend to others", "agree with message")

# Convert pfs_item to a factor with the specified order

data_pfs_boxplot_mutated <- data_pfs_boxplot %>%
  mutate(pfs_item = factor(pfs_item, levels = custom_order_pfs),
         ssi_choice = factor(ssi_choice, levels = custom_order_ssi))


```


```{r creating separate boxplot dfs per pfs item, include=FALSE}

data_pfs_boxplot_sep_1 <- data_pfs_boxplot_mutated %>%
  filter(pfs_item == "enjoyed")

data_pfs_boxplot_sep_2 <- data_pfs_boxplot_mutated %>%
  filter(pfs_item == "understood")

data_pfs_boxplot_sep_3 <- data_pfs_boxplot_mutated %>%
  filter(pfs_item == "easy to use")

data_pfs_boxplot_sep_4 <- data_pfs_boxplot_mutated %>%
  filter(pfs_item == "tried my hardest")

data_pfs_boxplot_sep_5 <- data_pfs_boxplot_mutated %>%
  filter(pfs_item == "helpful for others")

data_pfs_boxplot_sep_6 <- data_pfs_boxplot_mutated %>%
  filter(pfs_item == "recommend to others")

data_pfs_boxplot_sep_7 <- data_pfs_boxplot_mutated %>%
  filter(pfs_item == "agree with message")

```

```{r creating separate boxplots pfs item, include=FALSE, swarning=FALSE}

# Plotting

plot_boxplot_sep_1 <- ggplot(data_pfs_boxplot_sep_1, aes(x=value, 
                                     y = reorder(pfs_item, -as.numeric(pfs_item)), 
                                     fill=ssi_choice)) + 
                        geom_boxplot() +
                        scale_fill_manual(values = custom_colors) +
                        labs(x = "", y = "")
  
plot_boxplot_sep_2 <- ggplot(data_pfs_boxplot_sep_2, aes(x=value, 
                                     y = reorder(pfs_item, -as.numeric(pfs_item)), 
                                     fill=ssi_choice)) + 
                        geom_boxplot() +
                        scale_fill_manual(values = custom_colors) +
                        labs(x = "", y = "") +
                        theme(legend.position = "none")

plot_boxplot_sep_3 <- ggplot(data_pfs_boxplot_sep_3, aes(x=value, 
                                     y = reorder(pfs_item, -as.numeric(pfs_item)), 
                                     fill=ssi_choice)) + 
                        geom_boxplot() +
                        scale_fill_manual(values = custom_colors) +
                        labs(x = "", y = "") +
                        theme(legend.position = "none")

plot_boxplot_sep_4 <- ggplot(data_pfs_boxplot_sep_4, aes(x=value, 
                                     y = reorder(pfs_item, -as.numeric(pfs_item)), 
                                     fill=ssi_choice)) + 
                        geom_boxplot() +
                        scale_fill_manual(values = custom_colors) +
                        labs(x = "", y = "") +
                        theme(legend.position = "none")

plot_boxplot_sep_5 <- ggplot(data_pfs_boxplot_sep_5, aes(x=value, 
                                     y = reorder(pfs_item, -as.numeric(pfs_item)), 
                                     fill=ssi_choice)) + 
                        geom_boxplot() +
                        scale_fill_manual(values = custom_colors) +
                        labs(x = "", y = "") +
                        theme(legend.position = "none")

plot_boxplot_sep_6 <- ggplot(data_pfs_boxplot_sep_6, aes(x=value, 
                                     y = reorder(pfs_item, -as.numeric(pfs_item)), 
                                     fill=ssi_choice)) + 
                        geom_boxplot() +
                        scale_fill_manual(values = custom_colors) +
                        labs(x = "", y = "") +
                        theme(legend.position = "none")

plot_boxplot_sep_7 <- ggplot(data_pfs_boxplot_sep_7, aes(x=value, 
                                     y = reorder(pfs_item, -as.numeric(pfs_item)), 
                                     fill=ssi_choice)) + 
                        geom_boxplot() +
                        scale_fill_manual(values = custom_colors) +
                        labs(x = "pfs item scores", y = "") +
                        theme(legend.position = "none")

```

```{r creating combined pfs item boxplot, include=FALSE, warning=FALSE, message=FALSE, fig.width=8, fig.height=10}
  
# Combine the plots vertically

plot_all_boxplot <- plot_boxplot_sep_1 / plot_boxplot_sep_2 / plot_boxplot_sep_3 / plot_boxplot_sep_4 /
  plot_boxplot_sep_5 / plot_boxplot_sep_6 / plot_boxplot_sep_7 +
  plot_annotation(
    title = "PFS Items Scores for Each SSI",
    caption = "ABC (green), CARE (red), Project Personality (blue), RISE (orange); 
    higher scores reflect greater agreement"
  )

```

```{r printing combined pfs item boxplot, include=TRUE, warning=FALSE, message=FALSE, fig.width=8, fig.height=10}

plot_all_boxplot

```

# Drop-Offs

## ABC Project

Plotting number of page submissions by page number. This is a way to illustrate drop-off. Vertical lines are pages with writing exercises.

```{r selecting abc pages for plot, include=FALSE}

## Selecting only abc pages

data_abc_clicks <- data_youth_abc %>%
  select(contains("page_submit") & starts_with("abc"))

```

```{r mutating abc pages for count var, include=FALSE}

## Mutating non-NA values to value of 1 (i.e., a page was submitted)

data_abc_clicks_mutated <- data_abc_clicks %>%
  mutate(across(everything(), ~ case_when(
    !is.na(.) ~ 1,   # If the value is not NA, change it to "yes"
    TRUE ~ NA_real_  # Otherwise, make it NA
  )))

```

```{r prepping abc page data for plot, include=FALSE}

## Preparing data for plot

data_abc_clicks_plot <- data_abc_clicks_mutated %>%
    summarise(across(everything(), ~ sum(. == 1, na.rm = TRUE))) %>% # Count 1's in each column
    pivot_longer(cols = everything(), # Convert to long format
                 names_to = "variable", 
                 values_to = "count") %>%
    rename(page = variable, page_submissions = count) %>%
    mutate(page = str_extract_all(page, "\\d+") %>% # Extract all digits from page number variables
                  map_chr(paste0, collapse = "")) %>% # Collapse them into a single string
    mutate(page = as.numeric(page)) %>% # Converting to numeric class
    arrange(page) # Arrange in sequential page order

```

```{r plotting abc page data, include=FALSE}

## Plot page submissions by page

plot_abc_drop <- ggplot(data_abc_clicks_plot, aes(x=page, y=page_submissions)) +
  geom_area(fill="#32A2A0", alpha=0.4) +
  geom_line(color="#32A2A0", linewidth=1.1) +
  theme_light() +
  ylim(0, 1750) +
  ggtitle("") +
  labs(x = "page number",
       y = "n page submissions") +
  geom_vline(xintercept = 16, color = "black") +
  geom_vline(xintercept = 22, color = "black") +
  geom_vline(xintercept = 43, color = "black") +
  geom_vline(xintercept = 45, color = "black")

```

```{r abc page plot, include=TRUE}

plot_abc_drop

```

## Project CARE

Plotting number of page submissions by page number. This is a way to illustrate drop-off. Vertical lines are pages with writing exercises.

```{r selecting care pages for plot, include=FALSE}

## Selecting only care pages

data_care_clicks <- data_youth_care %>%
  select(contains("page_submit") & starts_with("proj_care"))

```

```{r mutating care pages for count var, include=FALSE}

## Mutating non-NA values to value of 1 (i.e., a page was submitted)

data_care_clicks_mutated <- data_care_clicks %>%
  mutate(across(everything(), ~ case_when(
    !is.na(.) ~ 1,   # If the value is not NA, change it to "yes"
    TRUE ~ NA_real_  # Otherwise, make it NA
  )))

```

```{r prepping care page data for plot, include=FALSE}

## Preparing data for plot

data_care_clicks_plot <- data_care_clicks_mutated %>%
    summarise(across(everything(), ~ sum(. == 1, na.rm = TRUE))) %>% # Count 1's in each column
    pivot_longer(cols = everything(), # Convert to long format
                 names_to = "variable", 
                 values_to = "count") %>%
    rename(page = variable, page_submissions = count) %>%
    mutate(page = str_extract_all(page, "\\d+") %>% # Extract all digits from page number variables
                  map_chr(paste0, collapse = "")) %>% # Collapse them into a single string
    mutate(page = as.numeric(page)) %>% # Converting to numeric class
    arrange(page) # Arrange in sequential page order

```

```{r largest drop in submissions care, echo=FALSE}

## Finding the largest drop in page submissions between two pages

largest_drop <- data_care_clicks_plot %>%
  mutate(drop = lag(page_submissions) - page_submissions) %>%  # Calculate drop from previous row
  filter(!is.na(drop)) %>%                                     # Remove NA values (first row has no previous value)
  slice_max(drop)                                              # Find the row with the largest drop

## Extracting the associated page values

page_before_drop <- largest_drop$page - 1  # Page before the drop
page_after_drop <- largest_drop$page       # Page after the drop

## Printing the pages associated with the largest drop

cat("The largest drop in page_submissions occurred between page", page_before_drop, "and page", page_after_drop, "\n")

```

```{r perc largest drop off care, echo=FALSE}

## Calculating largest drop off percentage

# Page submissions before and after drop

submissions_before_drop <- data_care_clicks_plot %>%
  filter(page == page_before_drop) %>%
  pull(page_submissions)

# Percentage calculation

perc_drop <- round((largest_drop$drop / submissions_before_drop)*100, 2)

## Printing the percent drop associated with the largest drop

cat(perc_drop, "% of cases that submitted page", page_before_drop, "did not submit page", page_after_drop, "\n")

```

```{r plotting care page data, include=FALSE}

## Plot page submissions by page

plot_care_drop <- ggplot(data_care_clicks_plot, aes(x=page, y=page_submissions)) +
  geom_area(fill="#A52B4D", alpha=0.4) +
  geom_line(color="#A52B4D", linewidth=1.1) +
  theme_light() +
  ylim(0, 1750) +
  ggtitle("") +
  labs(x = "page number",
       y = "n page submissions") +
  geom_vline(xintercept = 4, color = "black") +
  geom_vline(xintercept = 28, color = "black") +
  geom_vline(xintercept = 40, color = "black") +
  geom_vline(xintercept = 42, color = "black") +
  geom_vline(xintercept = 43, color = "black")

```

```{r care page plot, include=TRUE}

plot_care_drop

```

## Project Personality

Plotting number of page submissions by page number. This is a way to illustrate drop-off. Vertical lines are pages with writing exercises.

```{r selecting pp pages for plot, include=FALSE}

## Selecting only project personality pages

data_pp_clicks <- data_youth_pp %>%
  select(contains("page_submit") & starts_with("proj_pers"), 
         -contains("4_tim")) # this time var was on a separate not visible page to participants

```

```{r mutating pp pages for count var, include=FALSE}

## Mutating non-NA values to value of 1 (i.e., a page was submitted)

data_pp_clicks_mutated <- data_pp_clicks %>%
  mutate(across(everything(), ~ case_when(
    !is.na(.) ~ 1,   # If the value is not NA, change it to "yes"
    TRUE ~ NA_real_  # Otherwise, make it NA
  )))

```

```{r prepping pp page data for plot, include=FALSE}

## Preparing data for plot

data_pp_clicks_plot <- data_pp_clicks_mutated %>%
    summarise(across(everything(), ~ sum(. == 1, na.rm = TRUE))) %>% # Count 1's in each column
    pivot_longer(cols = everything(), # Convert to long format
                 names_to = "variable", 
                 values_to = "count") %>%
    rename(page = variable, page_submissions = count) %>%
    mutate(page = str_extract_all(page, "\\d+") %>% # Extract all digits from page number variables
                  map_chr(paste0, collapse = "")) %>% # Collapse them into a single string
    mutate(page = as.numeric(page)) %>% # Converting to numeric class
    arrange(page) # Arrange in sequential page order

```

```{r largest drop in submissions pp, echo=FALSE}

## Finding the largest drop in page submissions between two pages

largest_drop <- data_pp_clicks_plot %>%
  mutate(drop = lag(page_submissions) - page_submissions) %>%  # Calculate drop from previous row
  filter(!is.na(drop)) %>%                                     # Remove NA values (first row has no previous value)
  slice_max(drop)                                              # Find the row with the largest drop

## Extracting the associated page values

page_before_drop <- largest_drop$page - 1  # Page before the drop
page_after_drop <- largest_drop$page       # Page after the drop

## Printing the pages associated with the largest drop

cat("The largest drop in page_submissions occurred between page", page_before_drop, "and page", page_after_drop, "\n")

```

```{r perc largest drop off pp, echo=FALSE}

## Calculating largest drop off percentage

# Page submissions before and after drop

submissions_before_drop <- data_pp_clicks_plot %>%
  filter(page == page_before_drop) %>%
  pull(page_submissions)

# Percentage calculation

perc_drop <- round((largest_drop$drop / submissions_before_drop)*100, 2)

## Printing the percent drop associated with the largest drop

cat(perc_drop, "% of cases that submitted page", page_before_drop, "did not submit page", page_after_drop, "\n")

```

```{r plotting pp page data, include=FALSE}

## Saving value for plot arrow

pp_plot_arrow <- data_pp_clicks_plot %>%
  filter(page == 16) %>%
  pull(page_submissions)

## Plot Project Personality page submissions by page

plot_pp_drop <- ggplot(data_pp_clicks_plot, aes(x=page, y=page_submissions)) +
  geom_area(fill="#3F9CF5", alpha=0.4) +
  geom_line(color="#3F9CF5", linewidth=1.1) +
  theme_light() +
  ylim(0, 1750) +
  ggtitle("") +
  labs(x = "page number",
       y = "n page submissions") +
  geom_vline(xintercept = 16, color = "black") + 
  geom_vline(xintercept = 30, color = "black") +
  geom_vline(xintercept = 31, color = "black")

```

```{r pp page plot, include=TRUE}

plot_pp_drop

```

## Project RISE

Project RISE plot is unavailable, as we do not have timing variables on the pages of this intervention.

## All

Plotting drop-off for all SSIs. Curve slopes are steeper where drop-off is greater. Vertical lines are pages with writing exercises.

```{r combining all drop plots, warning=FALSE, message=FALSE, include=FALSE}

library(patchwork)

# Combine the plots vertically
plot_all_drop <- plot_abc_drop + plot_care_drop + plot_pp_drop + 
  plot_annotation(
    title = "Number of Page Submissions by Page of Each SSI",
    caption = "ABC (green), CARE (red), Project Personality (Blue); vertical lines are pages with writing exercises"
  )

```

```{r printing plot for all dropoff, include=TRUE}

plot_all_drop

```

# Knitting

Knitting the report to the outputs folder.

```{r knitting report, include=FALSE}

### This doesn't work

## Setting output directory for knit html reports and knitting

# render(as.character(here("scripts", "yes_report.Rmd")),
#        output_file = "yes_english_report.html",
#        output_dir = as.character(here("output")))

### This doesn't work either

# ## Defining the folder and file path
# 
# folder_path <- here("outputs")  # Path to my desired folder
# file_name <- "yes_english_report.html"
# full_path <- file.path(folder_path, file_name)
# 
# ## Kniting to .html report
# 
# render(input = "yes_report.Rmd", output_file = file_name, output_dir = full_path)

```