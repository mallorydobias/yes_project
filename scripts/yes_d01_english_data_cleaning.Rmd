---
title: "yes_data_cleaning"
author: "Mallory Dobias"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    toc: yes
    toc_depth: 5
    toc_float:
      collapsed: no
      smooth_scroll: no
  pdf_document:
    toc: yes
    toc_depth: '5'
  word_document:
    toc: yes
    toc_depth: '5'
geometry: margin=0.50in
---

```{r setup, include=FALSE}

## Setting up R

knitr::opts_chunk$set(echo = TRUE)

if(!require(pointblank)){install.packages('pointblank')}
library(pointblank) # installing and calling pointblank package early in Markdown

validate_rmd(summary = TRUE, log_to_file = FALSE) # allowing validation from pointblank package within Markdown

```

```{r, include=FALSE}

if(!require(here)){install.packages('here')}
library(here)

if(!require(janitor)){install.packages('janitor')}
library(janitor)

if(!require(dplyr)){install.packages('dplyr')}
library(dplyr)

if(!require(stringr)){install.packages('stringr')}
library(stringr)

if(!require(pointblank)){install.packages('pointblank')}
library(pointblank)

if(!require(tidyr)){install.packages('tidyr')}
library(tidyr)

if(!require(readr)){install.packages('readr')}
library(readr)

if(!require(lubridate)){install.packages('lubridate')}
library(lubridate)

```

# Data Reading

```{r reading in data from qualtrics survey}

## Reading in survey data

library(here) # places working directory at root of project folder

raw_data <- read.csv(here("data", "raw", "Project YES_February 13, 2025_13.25.csv")) # directing to data from project folder root

```

```{r reading in data from project yes pub}

## Reading in ids from cleaned data in yes pub

## Pulled from: https://osf.io/zguj4

old_ids <- read.csv(here("data", "raw", "yes_cleaned_using_r_april_5_2020_anonymized_for_osf.csv")) %>%
  select(response_id = id)

```

# Data Cleaning

## Cleaning Var Names

Removing Qualtrics metadata rows

```{r removing first two Qualtrics metadata rows}

## Removing first two rows with Qualtrics metadata

data_sliced <- raw_data %>%
  dplyr::slice(-1,-2)

# head(data_sliced) # looks good

```

```{r checking metadata removal setup, include = FALSE}

## checking Qualtrics metadata rows are removed

# pulling row 3 of raw data to compare to row 1 of sliced data

test_sliced_pre <- raw_data %>%
  dplyr::slice(3) # pulling pre-removal row 3 for comparison

test_sliced_post <- data_sliced %>%
  dplyr::slice(1) # pulling post-removal row 1 for comparison

# combining into one dataframe

test_sliced <- rbind(test_sliced_pre, test_sliced_post)

```

Checking metadata rows removed correctly

```{r checking metadata removal, validate = TRUE}

test_sliced %>%
  pointblank::col_vals_equal(vars(ResponseId), 
                             vars(ResponseId)) # passes if third row response is now first row

```

Converting to tidy var names

```{r creating tidy names}

## Cleaning var names

data_named <- data_sliced %>%
  janitor::clean_names()

# head(data_named)

```

Checking var names are tidy

```{r checking tidy names setup}

## checking var names are now tidy

test_var_names <- tibble(col_names = names(data_named)) # creates data frame of names

test_var_names %>%
  filter(stringr::str_detect(col_names, "[A-Z]")) %>%
  nrow() == 0 # true if zero col names contain capital letters

```

```{r renaming all unlabeled variables}

# Renaming all unlabeled variables

## This old version of yes did not collect qualtrics timing vars 
## on every page of the ssiss (proj pers)

## intervention qualtrics timing vars are renamed to match the
## var names for each specific slide in the most recent yes surveys
## (i.e., proj_pers_2_first_click named consistently to refer to
## the same intervention slide across all data sources)

data_renamed <- data_named %>%
  rename(perc_progress = progress,
         language = user_language,
         dem_race_ethnicity = q327,
         dem_age = q328,
         dem_adult = q329,
         dem_hear_proj = q330,
         dem_why_interest = q331,
         dem_receive_support = q332,
         dem_why_no_support = q333,
         dem_sex = q334,
         dem_gender_diff_sex = q335,
         dem_gender = q336,
         dem_gender_other_text = q336_17_text,
         dem_sex_orientation = q337,
         dem_sex_orientation_other_text = q337_9_text,
         ssi_prev_completed_choice = q353,
         ssi_times_completed_personality = q354,
         ssi_times_completed_care = q355,
         ssi_times_completed_abc = q356,
         ssi_choice = q357) %>%
  rename_with(~ str_replace(., "^q339_", "mfq_"), starts_with("q339_")) %>%
  rename_with(~ str_replace(., "^bhs_4_", "pre_bhs_"), starts_with("bhs_4_")) %>%
  rename_with(~ str_replace(., "^shs_agency_", "pre_shs_"), starts_with("shs_agency_")) %>%
  rename_with(~ str_replace(., "^q342_", "pre_self_hate_"), starts_with("q342_")) %>%
  rename(pre_perceived_control = q343_1) %>%
  rename_with(~ str_replace(., "^q498_", "proj_pers_2_"), starts_with("q498_")) %>%
  rename_with(~ str_replace(., "^q501_", "proj_pers_4_"), starts_with("q501_")) %>%
  rename_with(~ str_replace(., "^q504_", "proj_pers_6_"), starts_with("q504_")) %>%
  rename_with(~ str_replace(., "^q506_", "proj_pers_7_"), starts_with("q506_")) %>%
  rename_with(~ str_replace(., "^q512_", "proj_pers_12_"), starts_with("q512_")) %>%
  rename_with(~ str_replace(., "^q514_", "proj_pers_13_"), starts_with("q514_")) %>%
  rename_with(~ str_replace(., "^q516_", "proj_pers_14_"), starts_with("q516_")) %>%
  rename_with(~ str_replace(., "^q519_", "proj_pers_16_"), starts_with("q519_")) %>%
  rename(proj_pers_q_1_text = q520) %>%
  rename_with(~ str_replace(., "^q521_", "proj_pers_18_"), starts_with("q521_")) %>%
  rename_with(~ str_replace(., "^q525_", "proj_pers_21_"), starts_with("q525_")) %>%
  rename_with(~ str_replace(., "^q530_", "proj_pers_25_"), starts_with("q530_")) %>%
  rename_with(~ str_replace(., "^q532_", "proj_pers_26_"), starts_with("q532_")) %>%
  rename_with(~ str_replace(., "^q534_", "proj_pers_27_"), starts_with("q534_")) %>%
  rename_with(~ str_replace(., "^q537_", "proj_pers_30_"), starts_with("q537_")) %>%
  rename(proj_pers_q_2_text = q538) %>%
  rename_with(~ str_replace(., "^q539_", "proj_pers_31_"), starts_with("q539_")) %>%
  rename(proj_pers_q_3_text = q540) %>%
  rename_with(~ str_replace(., "^q359_", "abc_1_"), starts_with("q359_")) %>%
  rename_with(~ str_replace(., "^q361_", "abc_2_"), starts_with("q361_")) %>%
  rename_with(~ str_replace(., "^q363_", "abc_3_"), starts_with("q363_")) %>%
  rename_with(~ str_replace(., "^q365_", "abc_4_"), starts_with("q365_")) %>%
  rename_with(~ str_replace(., "^q443_", "abc_5_"), starts_with("q443_")) %>%
  rename(abc_q_1_1_num = q444_1) %>%
  rename_with(~ str_replace(., "^q367_", "abc_6_"), starts_with("q367_")) %>%
  rename(abc_q_2 = q369) %>%
  rename_with(~ str_replace(., "^q370_", "abc_7_"), starts_with("q370_")) %>%
  rename_with(~ str_replace(., "^q372_", "abc_8_"), starts_with("q372_")) %>%
  rename_with(~ str_replace(., "^q374_", "abc_9_"), starts_with("q374_")) %>%
  rename_with(~ str_replace(., "^q437_", "abc_10_"), starts_with("q437_")) %>%
  rename(abc_q_3_1_num = q438_1) %>%
  rename_with(~ str_replace(., "^q445_", "abc_11_"), starts_with("q445_")) %>%
  rename(abc_q_4 = q447) %>%
  rename_with(~ str_replace(., "^q448_", "abc_12_"), starts_with("q448_")) %>%
  rename_with(~ str_replace(., "^q450_", "abc_13_"), starts_with("q450_")) %>%
  rename_with(~ str_replace(., "^q452_", "abc_14_"), starts_with("q452_")) %>%
  rename_with(~ str_replace(., "^q439_", "abc_15_"), starts_with("q439_")) %>%
  rename(abc_q_5 = q440) %>%
  rename_with(~ str_replace(., "^q378_", "abc_18_"), starts_with("q378_")) %>%
  rename_with(~ str_replace(., "^q380_", "abc_19_"), starts_with("q380_")) %>%
  rename_with(~ str_replace(., "^q382_", "abc_20_"), starts_with("q382_")) %>%
  rename_with(~ str_replace(., "^q384_", "abc_21_"), starts_with("q384_")) %>%
  rename_with(~ str_replace(., "^q386_", "abc_22_"), starts_with("q386_")) %>%
  rename(abc_q_7 = q387) %>%
  rename(abc_q_8_text = q388) %>%
  rename_with(~ str_replace(., "^q389_", "abc_23_"), starts_with("q389_")) %>%
  rename_with(~ str_replace(., "^q391_", "abc_24_"), starts_with("q391_")) %>%
  rename_with(~ str_replace(., "^q393_", "abc_26_"), starts_with("q393_")) %>%
  rename(abc_q_9 = q394) %>%
  rename(abc_q_9_15_text = q394_15_text) %>%
  rename_with(~ str_replace(., "^q395_", "abc_27_"), starts_with("q395_")) %>%
  rename(abc_q_10 = q396) %>%
  rename_with(~ str_replace(., "^q397", "abc_q_11"), starts_with("q397")) %>%
  rename_with(~ str_replace(., "^q398", "abc_q_12"), starts_with("q398")) %>%
  rename_with(~ str_replace(., "^q399", "abc_q_13"), starts_with("q399")) %>%
  rename_with(~ str_replace(., "^q400", "abc_q_14"), starts_with("q400")) %>%
  rename_with(~ str_replace(., "^q401", "abc_q_15"), starts_with("q401")) %>%
  rename_with(~ str_replace(., "^q402_", "abc_32_"), starts_with("q402_")) %>%
  rename_with(~ str_replace(., "^q403", "abc_q_16"), starts_with("q403")) %>%
  rename_with(~ str_replace(., "^q404_", "abc_33_"), starts_with("q404_")) %>%
  rename_with(~ str_replace(., "^q406", "abc_q_17"), starts_with("q406")) %>%
  rename_with(~ str_replace(., "^q407", "abc_q_18"), starts_with("q407")) %>%
  rename_with(~ str_replace(., "^q408", "abc_q_19"), starts_with("q408")) %>%
  rename_with(~ str_replace(., "^q409", "abc_q_20"), starts_with("q409")) %>%
  rename_with(~ str_replace(., "^q410", "abc_q_21"), starts_with("q410")) %>%
  rename_with(~ str_replace(., "^q411_", "abc_34_"), starts_with("q411_")) %>%
  rename_with(~ str_replace(., "^q413_", "abc_35_"), starts_with("q413_")) %>%
  rename_with(~ str_replace(., "^q415_", "abc_37_"), starts_with("q415_")) %>%
  rename_with(~ str_replace(., "^q417_", "abc_38_"), starts_with("q417_")) %>%
  rename(abc_q_22 = q418) %>%
  rename_with(~ str_replace(., "^q419_", "abc_39_"), starts_with("q419_")) %>%
  rename_with(~ str_replace(., "^q421_", "abc_40_"), starts_with("q421_")) %>%
  rename_with(~ str_replace(., "^q423_", "abc_41_"), starts_with("q423_")) %>%
  rename_with(~ str_replace(., "^q425_", "abc_42_"), starts_with("q425_")) %>%
  rename(abc_q_23 = q426,
         abc_q_24 = q428,
         abc_q_24_7_text = q428_7_text,
         abc_q_24_8_text = q428_8_text,
         abc_q_24_9_text = q428_9_text) %>%
  rename_with(~ str_replace(., "^q427_", "abc_43_"), starts_with("q427_")) %>%
  # rename_with(~ str_replace(., "^q428", "abc_q_24"), starts_with("q428")) %>%
  rename_with(~ str_replace(., "^q429_", "abc_44_"), starts_with("q429_")) %>%
  rename_with(~ str_replace(., "^q435_", "abc_45_"), starts_with("q435_")) %>%
  rename(abc_q_37_text = q436,
         pfs_change = pfs_ch,
         pfs_more_feedback = pfs_etc,
         perc_change_hope = q351,
         perc_change_prob = q352) %>%
  rename_with(~ str_replace(., "^q542_", "post_bhs_"), starts_with("q542_")) %>%
  rename_with(~ str_replace(., "^q543_", "post_shs_"), starts_with("q543_")) %>%
  rename_with(~ str_replace(., "^q544_", "post_self_hate_"), starts_with("q544_")) %>%
  rename(post_perceived_control = q545_1,
         advice = q348,
         advice_permission = q349) %>%
  rename_with(~ str_replace(., "^q441_", "abc_16_"), starts_with("q441_")) %>%
  rename(abc_q_6_text = q442) %>%
  rename_with(~ str_replace(., "^q376_", "abc_17_"), starts_with("q376_")) %>%
  rename(proj_care_q_1_text = q457,
         proj_care_q_2_text = q480,
         proj_care_q_3 = q490,
         proj_care_q_4_text = q491,
         proj_care_q_5_text = q493,
         proj_care_q_6_text = q494,
         ssi_started = project_started,
         ssi_completed = project_completed) %>%
  rename_with(~ str_replace(., "(_page)", "_tim\\1"), contains("submit")) %>%
  rename_with(~ str_replace(., "(_click)", "_tim\\1"), contains("click_count")) %>%
  rename_with(~ str_replace(., "(_first)", "_tim\\1"), contains("first_click")) %>%
  rename_with(~ str_replace(., "(_last)", "_tim\\1"), contains("last_click"))
  
glimpse(data_renamed) # everything renamed for consistency

```

## Cleaning Values

Replacing empty cells with NAs

```{r replacing empty cells with nas}

## Replacing empty cells with NAs

data_w_nas <- data_renamed %>%
  mutate_all(~ na_if(., ""))

```

```{r checking nas setup, include=FALSE}

## Creating data frames of ids of folks with missing data for age pre and post nas

test_pre_nas <- data_renamed %>%
  filter(dem_age == "") %>%
  select(response_id) # ids with missing data pre nas ("")

test_post_nas <- data_w_nas %>%
  filter(is.na(dem_age)) %>%
  select(response_id) # ids with missing data post nas (NA)

# Get the unique names (names not in both data frames)

test_nas <- bind_rows(test_pre_nas, test_post_nas) %>%
  group_by(response_id) %>%
  filter(n() == 1)
         
```

Checking that nas mutation happened correctly

```{r checking reorg did not lose cols}

## Checking ids with empty data for age are identical to ids with nas for age

n_ids_missing_age <- test_nas %>%
  nrow() == 0

n_ids_missing_age # true if ids missing age data are identical pre and post age mutation

```

Cleaning values in start_date and end_date columns

```{r cleaning date columns}

data_dated <- data_w_nas %>%
  mutate(start_date = str_remove(start_date, " .*$"),
         end_date = str_remove(end_date, " .*$"))

```

```{r checking date cleaning setup, include=FALSE}

## Checking dates are identical pre to post cleaning

# pulling first 10 characters in date column pre-cleaning

test_pre_date <- data_w_nas %>%
  mutate(start_date = str_sub(start_date, 1, 10),
    end_date = str_sub(end_date, 1, 10)) %>%
  select(pre_start_date = start_date, pre_end_date = end_date)

# pulling first 10 characters in date column pre-cleaning

test_post_date <- data_dated %>%
  mutate(start_date = str_sub(start_date, 1, 10),
    end_date = str_sub(end_date, 1, 10)) %>%
  select(post_start_date = start_date, post_end_date = end_date)

# binding cols together for comparison

test_dates <- cbind(test_pre_date, test_post_date)

```

Checking dates cleaned correctly

```{r checking date cleaning, validate = TRUE}

## checking start_date and end_date are identical pre to post cleaning

test_dates %>%
  pointblank::col_vals_equal(vars(pre_start_date), 
                             vars(post_start_date)) %>%
  pointblank::col_vals_equal(vars(pre_end_date), 
                             vars(post_end_date)) # passes if dates are identical pre to post cleaning

```

Creating separate race and ethnicity columns, given participants could select multiple options. This will make it easier to quantify group totals later

```{r cleaning race and ethnicity}

## Cleaning race and ethnicity variable for easier totals

# creating one column per race/ethnicity response option
# adding no's in cases where participants responded to the question
# but did not endorse a particular racial or ethnic identity

data_race_cleaned <- data_dated %>%
  mutate(dem_race_asian = case_when(
    str_detect(dem_race_ethnicity, "Asian") ~ "yes",
    !str_detect(dem_race_ethnicity, "Asian") & !is.na(dem_race_ethnicity) ~ "no",
    TRUE ~ NA_character_)) %>%
  mutate(dem_race_black = case_when(
    str_detect(dem_race_ethnicity, "African American") ~ "yes",
    !str_detect(dem_race_ethnicity, "African American") & !is.na(dem_race_ethnicity) ~ "no",
    TRUE ~ NA_character_)) %>%
  mutate(dem_race_latin_hisp = case_when(
    str_detect(dem_race_ethnicity, "Latino/Hispanic") ~ "yes",
    !str_detect(dem_race_ethnicity, "Latino/Hispanic") & !is.na(dem_race_ethnicity) ~ "no",
    TRUE ~ NA_character_)) %>%
  mutate(dem_race_white = case_when(
    str_detect(dem_race_ethnicity, "Caucasian") ~ "yes",
    !str_detect(dem_race_ethnicity, "Caucasian") & !is.na(dem_race_ethnicity) ~ "no",
    TRUE ~ NA_character_)) %>%
  mutate(dem_race_other = case_when(
    str_detect(dem_race_ethnicity, "Other") ~ "yes",
    !str_detect(dem_race_ethnicity, "Other") & !is.na(dem_race_ethnicity) ~ "no",
    TRUE ~ NA_character_))

# data_race_cleaned %>%
#   select(contains("race")) # looks good

```

```{r checking race var cleaning setup, include=FALSE}

## Creating data frames of ids of folks endorsing Asian racial identity

test_pre_mutuate_count <- data_dated %>%
  filter(str_detect(dem_race_ethnicity, "Asian")) %>%
  select(pre_response_id = response_id) # ids of Asian participants pre mutation

test_post_mutate_count <- data_race_cleaned %>%
  filter(dem_race_asian == "yes") %>%
  select(post_response_id = response_id) # ids of Asian participants post mutation

## Creating data frames of ids of folks with missing data for race and ethnicity

test_pre_mutate_nas <- data_race_cleaned %>%
  filter(is.na(dem_race_ethnicity)) %>%
  select(pre_response_id = response_id)

test_post_mutate_nas <- data_race_cleaned %>%
  filter(is.na(dem_race_asian)) %>%
  select(post_response_id = response_id)

# combining data frames for comparison

test_mutate_count <- cbind(test_pre_mutuate_count, test_post_mutate_count)

test_mutate_nas <- cbind(test_pre_mutate_nas, test_post_mutate_nas)

```

Checking race variable cleaned correctly

```{r checking race cleaning, validate = TRUE}

## checking dem_race_asian and dem_race_ethnicity align pre to post cleaning

test_mutate_count %>%
  pointblank::col_vals_equal(vars(pre_response_id), 
                             vars(post_response_id)) # passes if yeses are identical pre to post cleaning

test_mutate_nas %>%
  pointblank::col_vals_equal(vars(pre_response_id), 
                             vars(post_response_id)) # passes if nas are identical pre to post cleaning

```

Creating separate gender identity columns, given participants could select multiple options. This will make it easier to quantify group totals later

```{r cleaning gender identity boys}

## Cleaning gender identity variable for easier totals

# creating one column per gender response option
# adding no's in cases where participants responded to the question
# but did not endorse a particular gender identity

# this is a little harder because the same character string
# appears in multiple answer choices;
# carefully selecting responses that have exact string only
# or exact string followed or preceded by a comma

## Boys and men

data_gender_boys_cleaned <- data_race_cleaned %>%
  rename(dem_gender_identity = dem_gender) %>%
  mutate(dem_gender_boy_man = case_when(
    str_detect(dem_gender_identity, "^Male$") | 
      str_detect(dem_gender_identity, "Male,") ~ "yes",
    !str_detect(dem_gender_identity, "^Male$") & 
      !str_detect(dem_gender_identity, "Male,") &
      !is.na(dem_gender_identity) ~ "no",
    TRUE ~ NA_character_)) 

# checking this worked

# data_gender_boys_cleaned %>%
#   filter(str_detect(dem_gender_identity, "Male")) %>%
#   select(dem_gender_identity, dem_gender_boy_man) # looks good

```

```{r cleaning gender identity girls}

## Girls and women

data_gender_girls_cleaned <- data_gender_boys_cleaned %>%
  mutate(dem_gender_girl_woman = case_when(
    str_detect(dem_gender_identity, "^Female$") | 
      str_detect(dem_gender_identity, "Female,") ~ "yes",
    !str_detect(dem_gender_identity, "^Female$") & 
      !str_detect(dem_gender_identity, "Female,") &
      !is.na(dem_gender_identity) ~ "no",
    TRUE ~ NA_character_)) 

```

```{r cleaning gender identity trans}

## Trans folks

data_gender_trans_cleaned <- data_gender_girls_cleaned %>%
  mutate(dem_gender_trans = case_when(
    str_detect(dem_gender_identity, "^Transgender$") | 
      str_detect(dem_gender_identity, "Transgender,") |
      str_detect(dem_gender_identity, ",Transgender") ~ "yes",
    !str_detect(dem_gender_identity, "^Transgender$") & 
      !str_detect(dem_gender_identity, "Transgender,") &
      !str_detect(dem_gender_identity, ",Transgender") &
      !is.na(dem_gender_identity) ~ "no",
    TRUE ~ NA_character_)) 

```

```{r cleaning gender identity ftm}

## FTM trans folks

data_gender_ftm_cleaned <- data_gender_trans_cleaned %>%
  mutate(dem_gender_ftm_trans = case_when(str_detect(dem_gender_identity, "FTM") ~ "yes",
    !str_detect(dem_gender_identity, "FTM") & !is.na(dem_gender_identity) ~ "no",
    TRUE ~ NA_character_)) 

```

```{r cleaning gender identity mtf}

## MTF trans folks

data_gender_mtf_cleaned <- data_gender_ftm_cleaned %>%
  mutate(dem_gender_mtf_trans = case_when(str_detect(dem_gender_identity, "MTF") ~ "yes",
    !str_detect(dem_gender_identity, "MTF") & !is.na(dem_gender_identity) ~ "no",
    TRUE ~ NA_character_)) 

```

```{r cleaning gender identity trans masc}

## Trans masc folks

data_gender_trans_masc_cleaned <- data_gender_mtf_cleaned %>%
  mutate(dem_gender_trans_masc = case_when(str_detect(dem_gender_identity, "masculine") ~ "yes",
    !str_detect(dem_gender_identity, "masculine") & !is.na(dem_gender_identity) ~ "no",
    TRUE ~ NA_character_)) 

```

```{r cleaning gender identity trans fem}

## Trans fem folks

data_gender_trans_fem_cleaned <- data_gender_trans_masc_cleaned %>%
  mutate(dem_gender_trans_fem = case_when(str_detect(dem_gender_identity, "feminine") ~ "yes",
    !str_detect(dem_gender_identity, "feminine") & !is.na(dem_gender_identity) ~ "no",
    TRUE ~ NA_character_)) 

```

```{r cleaning gender identity genderqueer}

## Genderqueer folks

data_gender_genderqueer_cleaned <- data_gender_trans_fem_cleaned %>%
  mutate(dem_gender_genderqueer = case_when(str_detect(dem_gender_identity, "Genderqueer") ~ "yes",
    !str_detect(dem_gender_identity, "Genderqueer") & !is.na(dem_gender_identity) ~ "no",
    TRUE ~ NA_character_)) 

```

```{r cleaning gender identity gender expansive}

## Gender expansive folks

data_gender_expansive_cleaned <- data_gender_genderqueer_cleaned %>%
  mutate(dem_gender_expansive = case_when(str_detect(dem_gender_identity, "expansive") ~ "yes",
    !str_detect(dem_gender_identity, "expansive") & !is.na(dem_gender_identity) ~ "no",
    TRUE ~ NA_character_)) 

```

```{r cleaning gender identity intersex}

## Intersex folks

data_gender_intersex_cleaned <- data_gender_expansive_cleaned %>%
  mutate(dem_gender_intersex = case_when(str_detect(dem_gender_identity, "Intersex") ~ "yes",
    !str_detect(dem_gender_identity, "Intersex") & !is.na(dem_gender_identity) ~ "no",
    TRUE ~ NA_character_)) 

```

```{r cleaning gender androgynous}

## Androgynous folks

data_gender_androgynous_cleaned <- data_gender_intersex_cleaned %>%
  mutate(dem_gender_androgynous = case_when(str_detect(dem_gender_identity, "Androgynous") ~ "yes",
    !str_detect(dem_gender_identity, "Androgynous") & !is.na(dem_gender_identity) ~ "no",
    TRUE ~ NA_character_)) 

```

```{r cleaning gender nonbinary}

## Nonbinary folks

data_gender_nonbinary_cleaned <- data_gender_androgynous_cleaned %>%
  mutate(dem_gender_nonbinary = case_when(str_detect(dem_gender_identity, "Nonbinary") ~ "yes",
    !str_detect(dem_gender_identity, "Nonbinary") & !is.na(dem_gender_identity) ~ "no",
    TRUE ~ NA_character_)) 

```

```{r cleaning gender two spirited}

## Two-spirited folks

data_gender_two_spirited_cleaned <- data_gender_nonbinary_cleaned %>%
  mutate(dem_gender_two_spirited = case_when(str_detect(dem_gender_identity, "Two-spirited") ~ "yes",
    !str_detect(dem_gender_identity, "Two-spirited") & !is.na(dem_gender_identity) ~ "no",
    TRUE ~ NA_character_)) 

```

```{r cleaning gender third gender}

## Third gender folks

data_gender_third_gender_cleaned <- data_gender_two_spirited_cleaned %>%
  mutate(dem_gender_third_gender = case_when(str_detect(dem_gender_identity, "Third") ~ "yes",
    !str_detect(dem_gender_identity, "Third") & !is.na(dem_gender_identity) ~ "no",
    TRUE ~ NA_character_)) 

```

```{r cleaning gender agender}

## Agender folks

data_gender_agender_cleaned <- data_gender_third_gender_cleaned %>%
  mutate(dem_gender_agender = case_when(str_detect(dem_gender_identity, "Agender") ~ "yes",
    !str_detect(dem_gender_identity, "Agender") & !is.na(dem_gender_identity) ~ "no",
    TRUE ~ NA_character_)) 

```

```{r cleaning gender unsure}

## Folks who endorse "unsure"

data_gender_unsure_cleaned <- data_gender_agender_cleaned %>%
  mutate(dem_gender_unsure = case_when(str_detect(dem_gender_identity, "Not sure") ~ "yes",
    !str_detect(dem_gender_identity, "Not sure") & !is.na(dem_gender_identity) ~ "no",
    TRUE ~ NA_character_)) 

```

```{r cleaning gender other}

## Folks who endorse "other"

data_gender_other_cleaned <- data_gender_unsure_cleaned %>%
  mutate(dem_gender_other = case_when(str_detect(dem_gender_identity, "Other") ~ "yes",
    !str_detect(dem_gender_identity, "Other") & !is.na(dem_gender_identity) ~ "no",
    TRUE ~ NA_character_))

```

Creating separate prev_completed variables for easier counting

```{r cleaning prev_completed values}

## Creating separate prev_completed variables for easier counting

data_prev_completed_cleaned <- data_gender_other_cleaned %>%
  rename(ssi_prev_completed_name = ssi_prev_completed_choice) %>%
  mutate(ssi_prev_completed_abc = case_when(str_detect(ssi_prev_completed_name, "A.B.C.") ~ "yes",
                                            TRUE ~ NA_character_),
         ssi_prev_completed_care = case_when(str_detect(ssi_prev_completed_name, "C.A.R.E.") ~ "yes",
                                            TRUE ~ NA_character_),
         ssi_prev_completed_pp = case_when(str_detect(ssi_prev_completed_name, "Project Personality") ~ "yes",
                                            TRUE ~ NA_character_)) %>%
  select(-ssi_prev_completed_name)
  
```

```{r checking prev_completed var cleaning setup, include=FALSE}

## Creating data frames of ids of folks who previously completed ABC

test_pre_mutate_count <- data_gender_other_cleaned %>%
  rename(ssi_prev_completed_name = ssi_prev_completed_choice) %>%
  filter(str_detect(ssi_prev_completed_name, "A.B.C.")) %>%
  select(pre_response_id = response_id) # ids of ABC participants pre mutation

test_post_mutate_count <- data_prev_completed_cleaned %>%
  filter(ssi_prev_completed_abc == "yes") %>%
  select(post_response_id = response_id) # ids of ABC participants post mutation

# combining data frames for comparison

test_mutate_count <- cbind(test_pre_mutate_count, test_post_mutate_count)

```

Checking ssi_prev_completed variables cleaned correctly

```{r checking prev_completed cleaning, validate = TRUE}

## checking prev_completed counts align pre to post cleaning

test_mutate_count %>%
  pointblank::col_vals_equal(vars(pre_response_id), 
                             vars(post_response_id)) # passes if yeses are identical pre to post cleaning

```

Cleaning the ssi_choice var

```{r combining ssi_choice and ssi_chose}

## Cleaning ssi_choice variable

data_ssi_choice_cleaned <- data_prev_completed_cleaned %>%
  mutate(ssi_choice = case_when(str_detect(ssi_choice, "A.B.C") ~ "ABC Project",
                                str_detect(ssi_choice, "C.A.R.E") ~ "Project CARE",
                                str_detect(ssi_choice, "Personality") ~ "Project Personality",
                                str_detect(ssi_choice, "RISE") ~ "Project RISE",
                                TRUE ~ ssi_choice))

```

## Calculating Composites

### Depression

Calculating depressive symptoms using the Short Form Mood and Feelings Questionnaire (only measured pre-SSI). Scores range from 0 to 26, where 0 = not true, 1 = sometimes, 2 = true. Scores of 12 or higher suggest depression. Source: https://doi.org/10.1002/mpr.1610

Mutating mfq character values to numeric values

```{r mutating mfq values}

## Mutating character values to numeric across multiple mfq columns 

data_mfq_mutated <- data_ssi_choice_cleaned %>%
  mutate(across(starts_with("mfq_") & -contains("tim"), 
                ~ case_when(
                    . == "Not True" ~ 0,
                    . == "Sometimes" ~ 1,
                    . == "True" ~ 2,
                    TRUE ~ NA_real_ # Handle other cases with NA
                )))

```

Checking mfq variables are now numeric class

```{r mfq numeric class check}

## Checking that all mfq vars are numeric class

data_mfq_mutated %>%
  select(contains("mfq") & -contains("tim")) %>%
  summarise(across(everything(), ~ class(.x)[1])) %>%
  tidyr::pivot_longer(cols = everything(), names_to = "variable", values_to = "class")


```

```{r checking mfq mutation setup, include=FALSE}

## checking mutation happened correctly - setting up for pointblank tests

# creating df of count for each response, pre mutation

test_mfq_pre <- data_ssi_choice_cleaned %>%
  group_by(mfq_1) %>% # grouping by response
  summarize(count = n()) %>% # counting responses pre-mutation
  arrange(desc(count)) %>% # arranged in descending count order
  rename(mfq_1_pre = mfq_1, count_pre = count) # renaming before combining to one df

# creating df of count for each response, post mutation

test_mfq_post <- data_mfq_mutated %>%
  mutate(across(starts_with("mfq_"), 
                ~ factor(., levels = unique(.)))) %>% # converting to factor class so we can count
  group_by(mfq_1) %>% # grouping by response
  summarize(count = n()) %>% # counting responses post-mutation
  arrange(desc(count)) %>% # arranged in descending count order
  rename(mfq_1_post = mfq_1, count_post = count) # renaming before combining to one df

# creating overall df for comparison

test_mfq_mutate <- cbind(test_mfq_pre, test_mfq_post)

```

```{r writing a function to setup future mutation checks, include=FALSE}

# Custom function to compare value counts before and after mutation
prep_mutation_check <- function(data_pre, data_post, var) {
  
  # Step 1: Create pre-mutation counts
  test_pre <- data_pre %>%
    select(var) %>%
    group_by(across(all_of(var))) %>%  # Group by the specified variable
    summarize(count = n(), .groups = "drop") %>%  # Count occurrences
    arrange(desc(count)) %>%  # Arrange in descending order
    rename_with(~ paste0(., "_pre"), everything())  # Rename columns for pre-mutation
  
  # Step 2: Create post-mutation counts
  test_post <- data_post %>%
    select(var) %>%
    mutate(across(all_of(var), ~ factor(., levels = unique(.)))) %>%  # Convert to factor
    group_by(across(all_of(var))) %>%  # Group by the specified variable
    summarize(count = n(), .groups = "drop") %>%  # Count occurrences
    arrange(desc(count)) %>%  # Arrange in descending order
    rename_with(~ paste0(., "_post"), everything())  # Rename columns for post-mutation
  
  # Step 3: Combine pre and post counts into one dataframe for comparison
  test_comparison <- bind_cols(test_pre, test_post)
  
  return(test_comparison)
}

```

```{r testing function to setup future mutation checks, include=FALSE}

# Example usage:
# Assuming `data_prev_completed_cleaned` is the pre-mutation dataframe
# and `data_mfq_mutated` is the post-mutation dataframe,
# and you want to compare the value counts of "mfq_1":

test_mutate <- prep_mutation_check(data_ssi_choice_cleaned, data_mfq_mutated, "mfq_1") # same output as test_mfq_mutate above

## will use the prep_mutation_check() function to set up mutation checks moving forward

```

Checking mfq response counts are identical from pre to post mutation

```{r mfq response counts validation, validate = TRUE}

test_mutate %>%
  pointblank::col_vals_equal(vars(count_pre), 
                             vars(count_post)) # passes if response counts are identical pre to post mutation

```

Calculating mfq composite scores

```{r calculating mfq scores}

## Calculating composite mfq scores

data_mfq_scored <- data_mfq_mutated %>%
  mutate(mfq_total = rowSums(across(starts_with("mfq_") & -contains("tim")), na.rm = TRUE)) %>%
  mutate(mfq_total = case_when(
    is.na(mfq_1) & is.na(mfq_2) & is.na(mfq_3) & is.na(mfq_4) & is.na(mfq_5) &
    is.na(mfq_6) & is.na(mfq_7) & is.na(mfq_8) & is.na(mfq_9) & is.na(mfq_10) &
    is.na(mfq_11) & is.na(mfq_12) & is.na(mfq_13)
     ~ NA_real_,
    TRUE ~ mfq_total
  ))

```

```{r checking mfq score setup, include = FALSE}

## checking composite calculation was correct

# manually calculating mfq totals to compare sum methods

test_mfq_calc <- data_mfq_scored %>%
  select(response_id, starts_with("mfq_") & -contains("tim")) %>%
  mutate(manual_mfq_total = mfq_1 + mfq_2 + mfq_3 + mfq_4 + mfq_5 +
                            mfq_6 + mfq_7 + mfq_8 + mfq_9 + mfq_10 +
                            mfq_11 + mfq_12 + mfq_13) %>%
  select(mfq_total, manual_mfq_total)

```

Checking mfq totals are identical across sum methods

```{r mfq scoring validation, validate = TRUE}

test_mfq_calc %>%
  pointblank::col_vals_equal(vars(mfq_total), 
                             vars(manual_mfq_total), 
                             na_pass = TRUE) # passes if mfq totals are identical across sum methods

```

### Hopelessness

Calculating hopelessness using the 4-item Beck's Hopelessness Scale (measured pre and post SSI). Row mean scores range from 0 to 3, where 0 = absolutely disagree, 1 = somewhat disagree, 2 = somewhat agree, 3 = absolutely agree on each item. Source: https://doi.org/10.1007/s10597-013-9619-1

```{r pulling bhs values, include=FALSE}

## Pulling mfq variables

# vars_bhs <- data_mfq_scored %>%
#   select(contains("bhs")) %>%
#   head() %>%
#   print()

```

Mutating bhs character values to numeric values

```{r mutating bhs values}

## Mutating character values to numeric across multiple bhs columns 

data_bhs_mutated <- data_mfq_scored %>%
  mutate(across(contains("bhs_") & -contains("tim"), 
                ~ case_when(
                    . == "Absolutely disagree" ~ 0,
                    . == "Somewhat disagree" ~ 1,
                    . == "Somewhat agree" ~ 2,
                    . == "Absolutely agree" ~ 3,
                    TRUE ~ NA_real_ # Handle other cases with NA
                )))

```

Checking bhs variables are now numeric class

```{r bhs numeric class check}

## Checking that all bhs vars are numeric class

data_bhs_mutated %>%
  select(contains("bhs")) %>%
  summarise(across(everything(), ~ class(.x)[1])) %>%
  tidyr::pivot_longer(cols = everything(), names_to = "variable", values_to = "class")


```

```{r using function to setup bhs mutation check, include=FALSE}

# `data_mfq_scored` is the pre-mutation dataframe
# and `data_bhs_mutated` is the post-mutation dataframe,
# and we want to compare the value counts of "pre_bhs_1":

test_mutate <- prep_mutation_check(data_mfq_scored, data_bhs_mutated, "pre_bhs_1")

```

Checking bhs response counts are identical from pre to post mutation

```{r bhs response counts validation, validate = TRUE}

test_mutate %>%
  pointblank::col_vals_equal(vars(count_pre), 
                             vars(count_post)) # passes if response counts are identical pre to post mutation

```

Calculating bhs row means

```{r calculating bhs scores}

## Calculating composite scores

data_bhs_scored <- data_bhs_mutated %>%
  mutate(pre_bhs_mean = rowMeans(across(starts_with("pre_bhs_") & -contains("tim")), na.rm = TRUE),
         post_bhs_mean = rowMeans(across(starts_with("post_bhs_") & -contains("tim")), na.rm = TRUE)) %>%
  mutate(across(contains("bhs_"), ~ case_when(
                                  is.nan(.) ~ NA_real_, # Replace NaN with NA
                                  TRUE ~ .))) # Keep other values unchanged

```

```{r checking bhs score setup, include = FALSE}

## checking composite calculation was correct

# manually calculating pre means to compare methods

test_pre_bhs_calc <- data_bhs_scored %>%
  select(response_id, starts_with("pre_bhs_") & -contains("tim")) %>%
  mutate(pre_manual_mean = rowMeans(select(., pre_bhs_1, pre_bhs_2, pre_bhs_3, pre_bhs_4), na.rm = TRUE)) %>%
  mutate(across(contains("manual"), ~ case_when(is.nan(.) ~ NA_real_, # Replace NaN with NA
                                        TRUE ~ .))) %>% # Keep other values unchanged
  select(pre_bhs_mean, pre_manual_mean)

# manually calculating post means to compare methods

test_post_bhs_calc <- data_bhs_scored %>%
  select(response_id, starts_with("post_bhs_") & -contains("tim")) %>%
  mutate(post_manual_mean = rowMeans(select(., post_bhs_1, post_bhs_2, post_bhs_3, post_bhs_4), na.rm = TRUE)) %>%
  mutate(across(contains("manual"), ~ case_when(is.nan(.) ~ NA_real_, # Replace NaN with NA
                                        TRUE ~ .))) %>% # Keep other values unchanged
  select(post_bhs_mean, post_manual_mean)

```

Checking pre and post bhs means are identical across averaging methods

```{r pre bhs scoring validation, validate = TRUE}

test_pre_bhs_calc %>%
  pointblank::col_vals_equal(vars(pre_bhs_mean), 
                             vars(pre_manual_mean), 
                             na_pass = TRUE) # passes if means are identical across methods

```

```{r post bhs scoring validation, validate = TRUE}

test_post_bhs_calc %>%
  pointblank::col_vals_equal(vars(post_bhs_mean), 
                             vars(post_manual_mean), 
                             na_pass = TRUE) # passes if means are identical across methods

```

### Hope (Pathways)

Calculating hope using the 3-item pathways subscale from the State Hope Scale (measured pre and post SSI). Row mean scores range from 1 to 8, where 1 = definitely false, and 8 = definitely true. Source: https://doi.org/10.1037/0022-3514.70.2.321

```{r pulling shs values, include=FALSE}

## Pulling shs variables

# vars_shs <- data_bhs_scored %>%
#   select(contains("shs")) %>%
#   head() %>%
#   print()

```

Mutating shs character values to numeric values

```{r mutating shs values}

## Mutating character values to numeric across multiple shs columns 

data_shs_mutated <- data_bhs_scored %>%
  mutate(across(contains("shs_") & -contains("tim"), 
                ~ case_when(
                    . == "Definitely False" ~ 1,
                    . == "Mostly False" ~ 2,
                    . == "Somewhat False" ~ 3,
                    . == "Slightly False" ~ 4,
                    . == "Slightly True" ~ 5,
                    . == "Somewhat True" ~ 6,
                    . == "Mostly True" ~ 7,
                    . == "Definitely True" ~ 8,
                    TRUE ~ NA_real_ # Handle other cases with NA
                )))
 
```

Checking shs variables are now numeric class

```{r shs numeric class check}

## Checking that all shs vars are numeric class

data_shs_mutated %>%
  select(contains("shs")) %>%
  summarise(across(everything(), ~ class(.x)[1])) %>%
  tidyr::pivot_longer(cols = everything(), names_to = "variable", values_to = "class")


```

```{r using function to setup shs mutation check, include=FALSE}

# `data_bhs_scored` is the pre-mutation dataframe
# and `data_shs_mutated` is the post-mutation dataframe,
# and we want to compare the value counts of "pre_shs_1":

test_mutate <- prep_mutation_check(data_bhs_scored, data_shs_mutated, "pre_shs_1")

```

Checking shs response counts are identical from pre to post mutation

```{r shs response counts validation, validate = TRUE}

test_mutate %>%
  pointblank::col_vals_equal(vars(count_pre), 
                             vars(count_post)) # passes if response counts are identical pre to post mutation

```
Calculating shs row means

```{r calculating shs scores}

## Calculating composite scores

data_shs_scored <- data_shs_mutated %>%
  mutate(pre_shs_mean = rowMeans(across(starts_with("pre_shs_") & -contains("tim")), na.rm = TRUE),
         post_shs_mean = rowMeans(across(starts_with("post_shs_") & -contains("tim")), na.rm = TRUE)) %>%
  mutate(across(contains("shs_"), ~ case_when(
                                  is.nan(.) ~ NA_real_, # Replace NaN with NA
                                  TRUE ~ .))) # Keep other values unchanged

```

```{r checking shs score setup, include = FALSE}

## checking composite calculation was correct

# manually calculating pre means to compare methods

test_pre_shs_calc <- data_shs_scored %>%
  select(response_id, starts_with("pre_shs_") & -contains("tim")) %>%
  mutate(pre_manual_mean = rowMeans(select(., pre_shs_1, pre_shs_2, pre_shs_3), na.rm = TRUE)) %>%
  mutate(across(contains("manual"), ~ case_when(is.nan(.) ~ NA_real_, # Replace NaN with NA
                                        TRUE ~ .))) %>% # Keep other values unchanged
  select(pre_shs_mean, pre_manual_mean)

# manually calculating post means to compare methods

test_post_shs_calc <- data_shs_scored %>%
  select(response_id, starts_with("post_shs_") & -contains("tim")) %>%
  mutate(post_manual_mean = rowMeans(select(., post_shs_1, post_shs_2, post_shs_3), na.rm = TRUE)) %>%
  mutate(across(contains("manual"), ~ case_when(is.nan(.) ~ NA_real_, # Replace NaN with NA
                                        TRUE ~ .))) %>% # Keep other values unchanged
  select(post_shs_mean, post_manual_mean)

```

Checking pre and post shs means are identical across averaging methods

```{r pre shs scoring validation, validate = TRUE}

test_pre_shs_calc %>%
  pointblank::col_vals_equal(vars(pre_shs_mean), 
                             vars(pre_manual_mean), 
                             na_pass = TRUE) # passes if means are identical across methods

```

```{r post shs scoring validation, validate = TRUE}

test_post_shs_calc %>%
  pointblank::col_vals_equal(vars(post_shs_mean), 
                             vars(post_manual_mean), 
                             na_pass = TRUE) # passes if means are identical across methods

```

### Self-Hate

Calculating self-hate using a 3-item version of the Self-Hate Scale (measured pre and post SSI). Row mean scores range from 1 to 6, where 1 = not at all true for me, and 6 = very true for me. Source (abbreviated scale): https://mental.jmir.org/2020/6/e20513. Source (full scale): https://doi.org/10.1016/j.jad.2018.11.047 

NOTE: The original scale is a 7-point Likert scale, we've used 6-point Likert scales for items in this data and in the original YES data. 

```{r pulling selfhate values, include=FALSE}

## Pulling selfhate variables

# vars_hate <- data_shs_scored %>%
#   select(contains("self_hate")) %>%
#   head() %>%
#   print()

```

Mutating hate character values to numeric values

```{r mutating hate values}

## Converting number character values from sliding scale to numeric values

data_hate_mutated <- data_shs_scored %>%
  mutate(across(contains("self_hate_") & -contains("tim"), 
                ~ case_when(
                    . == "very true for me" ~ "6",
                    . == "not at all true for me" ~ "1",
                    TRUE ~ .)) %>%
  mutate(across(contains("self_hate") & where(is.character), as.numeric)))

```

Checking hate variables are now numeric class

```{r hate numeric class check}

## Checking that all self-hate vars are numeric class

data_hate_mutated %>%
  select(contains("self_hate")) %>%
  summarise(across(everything(), ~ class(.x)[1])) %>%
  tidyr::pivot_longer(cols = everything(), names_to = "variable", values_to = "class")


```

Calculating hate row means

```{r calculating hate scores}

## Calculating composite scores

data_hate_scored <- data_hate_mutated %>%
  mutate(pre_self_hate_mean = rowMeans(across(starts_with("pre_self_hate_") & -contains("tim")), na.rm = TRUE),
         post_self_hate_mean = rowMeans(across(starts_with("post_self_hate_") & -contains("tim")), na.rm = TRUE)) %>%
  mutate(across(contains("self_hate_"), ~ case_when(
                                  is.nan(.) ~ NA_real_, # Replace NaN with NA
                                  TRUE ~ .))) # Keep other values unchanged

```

```{r checking hate score setup, include = FALSE}

## checking composite calculation was correct

# manually calculating pre means to compare methods

test_pre_hate_calc <- data_hate_scored %>%
  select(response_id, starts_with("pre_self_hate_") & -contains("tim")) %>%
  mutate(pre_manual_mean = rowMeans(select(., pre_self_hate_1, pre_self_hate_2, pre_self_hate_3), na.rm = TRUE)) %>%
  mutate(across(contains("manual"), ~ case_when(is.nan(.) ~ NA_real_, # Replace NaN with NA
                                        TRUE ~ .))) %>% # Keep other values unchanged
  select(pre_self_hate_mean, pre_manual_mean)

# manually calculating post means to compare methods

test_post_hate_calc <- data_hate_scored %>%
  select(response_id, starts_with("post_self_hate_") & -contains("tim")) %>%
  mutate(post_manual_mean = rowMeans(select(., post_self_hate_1, post_self_hate_2, post_self_hate_3), na.rm = TRUE)) %>%
  mutate(across(contains("manual"), ~ case_when(is.nan(.) ~ NA_real_, # Replace NaN with NA
                                        TRUE ~ .))) %>% # Keep other values unchanged
  select(post_self_hate_mean, post_manual_mean)

```

Checking pre and post hate means are identical across averaging methods

```{r pre hate scoring validation, validate = TRUE}

test_pre_hate_calc %>%
  pointblank::col_vals_equal(vars(pre_self_hate_mean), 
                             vars(pre_manual_mean), 
                             na_pass = TRUE) # passes if means are identical across methods

```

```{r post hate scoring validation, validate = TRUE}

test_post_hate_calc %>%
  pointblank::col_vals_equal(vars(post_self_hate_mean), 
                             vars(post_manual_mean), 
                             na_pass = TRUE) # passes if means are identical across methods

```

### PFS

Calculating program feedback scores using the Program feedback scale (measured post SSI). Row mean scores range from 1 to 5, where 1 = really disagree, and 5 = really agree. Source: https://mental.jmir.org/2020/6/e20513

```{r pulling pfs values, include=FALSE}

## Pulling pfs variables

# vars_pfs <- data_hate_scored %>%
#   select(contains("pfs") & -contains("like") & 
#            -contains("change") & 
#            -contains("more") &
#            -contains("tim")) %>%
#   head() %>%
#   print()

```

Mutating pfs character values to numeric values

```{r mutating pfs values}

## Mutating character values to numeric across multiple pfs columns 

data_pfs_mutated <- data_hate_scored %>%
  mutate(across(contains("pfs_") & -contains("like") & 
               -contains("change") &
               -contains("more") &
               -contains("tim"),
                ~ case_when(
                    . == "Really Disagree" ~ 1,
                    . == "Diagree" ~ 2, # disagree is misspelled in this survey
                    . == "Neutral" ~ 3,
                    . == "Agree" ~ 4,
                    . == "Really Agree" ~ 5,
                    TRUE ~ NA_real_ # Handle other cases with NA
                )))
 
```

Checking pfs variables are now numeric class

```{r pfs numeric class check}

## Checking that all pfs vars are numeric class

data_pfs_mutated %>%
  select(contains("pfs") & 
         -contains("like") & 
         -contains("change") &
         -contains("more") &
         -contains("tim"),) %>%
  summarise(across(everything(), ~ class(.x)[1])) %>%
  tidyr::pivot_longer(cols = everything(), names_to = "variable", values_to = "class")


```

```{r using function to setup pfs mutation check, include=FALSE}

# `data_hate_scored` is the pre-mutation dataframe
# and `data_pfs_mutated` is the post-mutation dataframe,
# and we want to compare the value counts of "pfs_1":

test_mutate <- prep_mutation_check(data_hate_scored, data_pfs_mutated, "pfs_1")

data_hate_scored %>%
  select(contains("pfs_1"))

data_pfs_mutated %>%
  select(contains("pfs_1"))

```

Checking pfs response counts are identical from pre to post mutation

```{r pfs response counts validation, validate = TRUE}

test_mutate %>%
  pointblank::col_vals_equal(vars(count_pre), 
                             vars(count_post)) # passes if response counts are identical pre to post mutation

```

Calculating pfs row means

```{r calculating pfs scores}

## Calculating composite scores

data_pfs_scored <- data_pfs_mutated %>%
  # Calculate the row means of relevant pfs_ columns, excluding specific patterns
  mutate(pfs_mean = rowMeans(across(contains("pfs_") & 
                                    !contains("like") & 
                                    !contains("change") &
                                    !contains("more") &
                                    !contains("tim")), na.rm = TRUE)) %>%
  # Replace NaN values with NA_real_ across relevant pfs columns
  mutate(across(contains("pfs_") &
                !contains("like") & 
                !contains("change") &
                !contains("more") &
                !contains("tim"),
                ~ case_when(is.nan(.x) ~ NA_real_,  # Replace NaN with NA
                            TRUE ~ .x))) # Keep other values unchanged

```

```{r checking pfs score setup, include = FALSE}

## checking composite calculation was correct

# manually calculating means to compare methods

test_pfs_calc <- data_pfs_scored %>%
  select(response_id, starts_with("pfs") & 
                                    !contains("like") & 
                                    !contains("change") &
                                    !contains("more") &
                                    !contains("tim")) %>%
  mutate(manual_mean = rowMeans(select(., pfs_1, pfs_2, pfs_3, pfs_4, pfs_5, pfs_6, pfs_7), na.rm = TRUE)) %>%
  mutate(across(contains("manual"), ~ case_when(is.nan(.) ~ NA_real_, # Replace NaN with NA
                                        TRUE ~ .))) %>% # Keep other values unchanged
  select(pfs_mean, manual_mean)

```

Checking pfs mean is identical across averaging methods

```{r pfs scoring validation, validate = TRUE}

test_pfs_calc %>%
  pointblank::col_vals_equal(vars(pfs_mean), 
                             vars(manual_mean), 
                             na_pass = TRUE) # passes if means are identical across averaging methods

```

## Reorganizing Columns

Dropping unnecessary columns

```{r dropping cols}

data_col_dropped <- data_pfs_scored %>%
  select(-status, -contains("duration"), -contains("recipient"), -contains("external"), -contains("distribution"), 
         -recorded_date, -language) %>% # dropping unnecessary qualtrics metadata
  select(-sc0, -sc1, -sc2, -sc7, -sc8, -mood_change) %>% # dropping scale scores calculated within qualtrics
  select(-create_new_field_or_choose_from_dropdown, -q216_17_text_topics) %>% # dropping empty cols
  select(-dem_race_ethnicity, -dem_gender_identity) # dropping outdated cols cleaned above

# glimpse(data_col_dropped)

```

Adding cols to document language and data source

```{r adding cols}

data_col_added <- data_col_dropped %>%
  mutate(language = "english",
         data_id = "d01")

```

Reorganizing column order to place important columns first, and then to follow chronological order

```{r reorganizing col order}

## Reorganizing cols to prioritize important cols first and then chronological order

data_reorged <- data_col_added %>%
  select(response_id, language, data_id, contains("date"), ip_address, starts_with("location"),
         perc_progress, finished, ssi_choice,
         starts_with("volunteer_") & !contains("tim"),
         dem_hear_proj, dem_why_interest, dem_receive_support, dem_why_no_support, dem_adult, dem_age, dem_sex,
         starts_with("dem_gender_") & !contains("tim"),
         starts_with("dem_sex_orientation") & !contains("tim"), 
         starts_with("dem_race") & !contains("tim"),
         starts_with("ssi_prev"), starts_with("ssi_times"), 
         starts_with("mfq_") & !contains("tim"), 
         starts_with("pre_bhs_") & !contains("tim"), 
         starts_with("pre_shs_") & !contains("tim"), 
         starts_with("pre_self_hate_") & !contains("tim"),
         starts_with("pre_perceived_control") & !contains("tim"),
         ssi_started,
         starts_with("abc") & !contains("tim"),
         starts_with("proj_care") & !contains("tim"),
         starts_with("proj_pers") & !contains("tim"),
         starts_with("proj_rise") & !contains("tim"),
         ssi_completed,
         starts_with("advice") & !contains("tim"),
         starts_with("pfs_") & !contains("tim"),
         starts_with("perc_change_") & !contains("tim"),
         starts_with("post_bhs_") & !contains("tim"),
         starts_with("post_shs_") & !contains("tim"),
         starts_with("post_self_hate_") & !contains("tim"),
         starts_with("post_perceived_control") & !contains("tim"),
         contains("tim") & starts_with("intro"),
         contains("tim") & starts_with("volunteer"),
         contains("tim") & starts_with("dem"),
         contains("tim") & starts_with("ssi"),
         contains("tim") & starts_with("mfq"),
         contains("tim") & starts_with("pre_"),
         contains("tim") & starts_with("abc"),
         contains("tim") & starts_with("proj_care"),
         contains("tim") & starts_with("proj_rise"),
         contains("tim") & starts_with("proj_pers"),
         contains("tim") & starts_with("advice_"),
         contains("tim") & starts_with("pfs_"),
         contains("tim") & starts_with("perc_change_"),
         contains("tim") & starts_with("post_"))

```

```{r checking col order setup, include=FALSE}

## creating data frames of names pre and post reorg for comparison

pre_reorg_names <- data_col_added %>%
  names() # names pre

post_reorg_names <- data_reorged %>%
  names() # names post

# Create tibbles for easier manipulation

pre_reorg_df <- tibble(names = pre_reorg_names)
post_reorg_df <- tibble(names = post_reorg_names)

# Get the unique names (names not in both data frames)

test_reorg <- bind_rows(pre_reorg_df, post_reorg_df) %>%
  group_by(names) %>%
  filter(n() == 1)
         
```

Checking that reorganizing happened correctly (i.e., no columns dropped) 

```{r checking reorg did not lose cols 2}

## Checking if df with any columns unique to pre-reorg data is empty (i.e., no columns dropped)

n_cols_dropped <- test_reorg %>%
  nrow() == 0

n_cols_dropped # true if no columns were dropped by reorg

```

## Converting Classes

Converting variable classes

```{r mutating var classes}

data_classes_mutated <- data_reorged %>%
  select(-ip_address, -starts_with("location")) %>%
  mutate(language = as.factor(language),
         data_id = as.factor(data_id),
         perc_progress = as.numeric(perc_progress),
         finished = as.factor(finished),
         pre_perceived_control = as.numeric(pre_perceived_control),
         post_perceived_control = as.numeric(post_perceived_control),
         ssi_choice = as.factor(ssi_choice),
         ssi_started = as.factor(ssi_started),
         ssi_completed = as.factor(ssi_completed),
         advice_permission = as.factor(advice_permission)) %>%
  mutate(across(contains("date"), as.Date)) %>%
  mutate(across(matches("^dem_.*") & !matches("why|hear|text"), as.factor)) %>%
  mutate(across(contains("times_completed"), as.numeric)) %>%
  mutate(across(contains("ssi_prev_completed"), as.factor)) %>%
  mutate(across(contains("_q_") & ends_with("_num"), as.numeric)) %>% # ssi numeric questions
  mutate(across(contains("_q_") & -ends_with("_text") & -ends_with("_num") &
                -ends_with("_rank") & -ends_with("_group"), as.factor)) %>% # ssi qual questions
  mutate(across(contains("commit"), as.factor)) %>%
  mutate(across(contains("perc_change"), as.factor)) %>%
  mutate(across(contains("_tim_"), as.numeric))

# glimpse(data_classes_mutated)

```

# Filtering Observations

Here, we remove observations that were previously included in the Project YES publication, by response_id. 

```{r pulling response ids in both this data and old pub data}

full_ids <- data_classes_mutated %>%
  select(response_id) # ids from this survey data

old_ids # ids from the original yes pub

ids_to_drop <- inner_join(full_ids, old_ids, by = "response_id") # ids in both

n_ids_in_both <- ids_to_drop %>%
  nrow() # saving n ids that should be dropped

```

```{r filtering out old pub ids}

# Dropping ids that are in old pub data

data_new_ids_only <- anti_join(data_classes_mutated, old_ids, by = "response_id")
  
## Checking n dropped is as expected

n_expected_remaining <- nrow(data_classes_mutated) - n_ids_in_both 

n_actual_remaining <- nrow(data_new_ids_only)

n_expected_remaining == n_actual_remaining # true if actual rows remaining = expected

## Checking no ids from dropped list are in final data

test_ids_should_be_zero <- inner_join(ids_to_drop, data_new_ids_only, by = "response_id")

nrow(test_ids_should_be_zero) == 0 # true if no old ids in new data

```

```{r dropping recent fake entry}

# Dropping empty observation from 3 years post-survey

data_drop_recent_observation <- data_new_ids_only %>%
  filter(start_date != "2024-02-04")

```

# Saving Data

```{r saving cleaned data}

data <- data_new_ids_only

# Define the folder and file path

folder_path <- here("data", "clean")  # Path to my desired folder
file_name <- "yes_data_d01_english_clean.Rds"
full_path <- file.path(folder_path, file_name)

# Save the dataframe to the file

saveRDS(data, full_path)

```
